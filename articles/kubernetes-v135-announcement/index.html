<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><link rel="preload" href="/_next/static/media/graziano-casto.17cc67b9.jpg" as="image" fetchpriority="high"/><title>Kubernetes v1.35: Timbernetes (The World Tree Release) - by Graziano Casto</title><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kubernetes v1.35: Timbernetes (The World Tree Release)","datePublished":"2025-12-17T00:00:00.000Z","dateModified":"2025-12-17T00:00:00.000Z","author":[{"@type":"Person","name":"Graziano Casto","url":"https://castograziano.com/about-me"}]}</script><meta name="description" content="Kubernetes v1.35: Timbernetes (The World Tree Release) - by Graziano Casto"/><meta name="keywords" content="Cloud Native, Kubernetes, Developer Experience, Platform Engineering, DevRel"/><meta name="google-site-verification" content="nwBPkfmfDfedHF9qe1qSlQtAuBQICJ5STXjbfnTzEDA"/><link rel="canonical" href="https://www.castograziano.comhttps://castograziano.com/articles/kubernetes-v135-announcement"/><link rel="manifest" href="/site.webmanifest"/><meta property="og:title" content="Kubernetes v1.35: Timbernetes (The World Tree Release) - by Graziano Casto"/><meta property="og:description" content="Kubernetes v1.35: Timbernetes (The World Tree Release) - by Graziano Casto"/><meta property="og:url" content="https://www.castograziano.comhttps://castograziano.com/articles/kubernetes-v135-announcement"/><meta property="og:image" content="https://castograziano.com/casto_graziano_personal_website.png"/><meta property="og:type" content="article"/><meta property="og:locale" content="en_US"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Kubernetes v1.35: Timbernetes (The World Tree Release) - by Graziano Casto"/><meta name="twitter:description" content="Kubernetes v1.35: Timbernetes (The World Tree Release) - by Graziano Casto"/><meta name="twitter:image" content="https://castograziano.com/casto_graziano_personal_website.png"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="icon" href="/images/favicon.ico"/><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"/><meta name="next-head-count" content="24"/><link rel="preload" href="/_next/static/css/bcb19791dba4e2b1.css" as="style"/><link rel="stylesheet" href="/_next/static/css/bcb19791dba4e2b1.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-6ef43a8d4a395f49.js" defer=""></script><script src="/_next/static/chunks/framework-2c16ac744b6cdea6.js" defer=""></script><script src="/_next/static/chunks/main-69b16c27ce463005.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a8fe774887236273.js" defer=""></script><script src="/_next/static/chunks/pages/articles/%5Bslug%5D-c4c21cb19e720b8c.js" defer=""></script><script src="/_next/static/L5vrGkgVuQJWNjQ2eNbXG/_buildManifest.js" defer=""></script><script src="/_next/static/L5vrGkgVuQJWNjQ2eNbXG/_ssgManifest.js" defer=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><div class="flex w-full"><div class="fixed inset-0 flex justify-center sm:px-8"><div class="flex w-full max-w-7xl lg:px-8"><div class="w-full bg-white ring-1 ring-zinc-100 dark:bg-zinc-900 dark:ring-zinc-300/20"></div></div></div><div class="relative flex w-full flex-col"><header class="pointer-events-none relative z-50 flex flex-none flex-col" style="height:var(--header-height);margin-bottom:var(--header-mb)"><div class="top-0 z-10 h-16 pt-6" style="position:var(--header-position)"><div class="sm:px-8 top-[var(--header-top,theme(spacing.6))] w-full" style="position:var(--header-inner-position)"><div class="mx-auto w-full max-w-7xl lg:px-8"><div class="relative px-4 sm:px-8 lg:px-12"><div class="mx-auto max-w-2xl lg:max-w-5xl"><div class="relative flex gap-4"><div class="flex flex-1"><div class="h-10 w-10 rounded-full bg-white/90 p-0.5 shadow-lg shadow-zinc-800/5 ring-1 ring-zinc-900/5 backdrop-blur dark:bg-zinc-800/90 dark:ring-white/10"><a aria-label="Home" class="pointer-events-auto" href="/"><img alt="" fetchpriority="high" width="1872" height="1914" decoding="async" data-nimg="1" class="rounded-full bg-zinc-100 object-cover dark:bg-zinc-800 h-9 w-9" style="color:transparent" src="/_next/static/media/graziano-casto.17cc67b9.jpg"/></a></div></div><div class="flex flex-1 justify-end md:justify-center"><div class="pointer-events-auto md:hidden" data-headlessui-state=""><button class="group flex items-center rounded-full bg-white/90 px-4 py-2 text-sm font-medium text-zinc-800 shadow-lg shadow-zinc-800/5 ring-1 ring-zinc-900/5 backdrop-blur dark:bg-zinc-800/90 dark:text-zinc-200 dark:ring-white/10 dark:hover:ring-white/20" type="button" aria-expanded="false" data-headlessui-state="">Menu<svg viewBox="0 0 8 6" aria-hidden="true" class="ml-3 h-auto w-2 stroke-zinc-500 group-hover:stroke-zinc-700 dark:group-hover:stroke-zinc-400"><path d="M1.75 1.75 4 4.25l2.25-2.5" fill="none" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg></button></div><div hidden="" style="position:fixed;top:1px;left:1px;width:1px;height:0;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0;display:none"></div><nav class="pointer-events-auto hidden md:block"><ul class="flex rounded-full bg-white/90 px-3 text-sm font-medium text-zinc-800 shadow-lg shadow-zinc-800/5 ring-1 ring-zinc-900/5 backdrop-blur dark:bg-zinc-800/90 dark:text-zinc-200 dark:ring-white/10"><li><a class="relative block px-3 py-2 transition hover:text-teal-500 dark:hover:text-teal-400" href="/about-me/">About</a></li><li><a class="relative block px-3 py-2 transition hover:text-teal-500 dark:hover:text-teal-400" href="/articles/">Articles</a></li><li><a class="relative block px-3 py-2 transition hover:text-teal-500 dark:hover:text-teal-400" href="/speaking/">Speaking</a></li><li><a class="relative block px-3 py-2 transition hover:text-teal-500 dark:hover:text-teal-400" href="/projects/">Projects</a></li></ul></nav></div><div class="flex justify-end md:flex-1"><div class="pointer-events-auto"><button type="button" aria-label="Toggle theme" class="group rounded-full bg-white/90 px-3 py-2 shadow-lg shadow-zinc-800/5 ring-1 ring-zinc-900/5 backdrop-blur transition dark:bg-zinc-800/90 dark:ring-white/10 dark:hover:ring-white/20"><svg viewBox="0 0 24 24" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" class="h-6 w-6 fill-zinc-100 stroke-zinc-500 transition group-hover:fill-zinc-200 group-hover:stroke-zinc-700 dark:hidden [@media(prefers-color-scheme:dark)]:fill-teal-50 [@media(prefers-color-scheme:dark)]:stroke-teal-500 [@media(prefers-color-scheme:dark)]:group-hover:fill-teal-50 [@media(prefers-color-scheme:dark)]:group-hover:stroke-teal-600"><path d="M8 12.25A4.25 4.25 0 0 1 12.25 8v0a4.25 4.25 0 0 1 4.25 4.25v0a4.25 4.25 0 0 1-4.25 4.25v0A4.25 4.25 0 0 1 8 12.25v0Z"></path><path d="M12.25 3v1.5M21.5 12.25H20M18.791 18.791l-1.06-1.06M18.791 5.709l-1.06 1.06M12.25 20v1.5M4.5 12.25H3M6.77 6.77 5.709 5.709M6.77 17.73l-1.061 1.061" fill="none"></path></svg><svg viewBox="0 0 24 24" aria-hidden="true" class="hidden h-6 w-6 fill-zinc-700 stroke-zinc-500 transition dark:block [@media(prefers-color-scheme:dark)]:group-hover:stroke-zinc-400 [@media_not_(prefers-color-scheme:dark)]:fill-teal-400/10 [@media_not_(prefers-color-scheme:dark)]:stroke-teal-500"><path d="M17.25 16.22a6.937 6.937 0 0 1-9.47-9.47 7.451 7.451 0 1 0 9.47 9.47ZM12.75 7C17 7 17 2.75 17 2.75S17 7 21.25 7C17 7 17 11.25 17 11.25S17 7 12.75 7Z" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg></button></div></div></div></div></div></div></div></div></header><main class="flex-auto"><div class="sm:px-8 mt-16 lg:mt-32"><div class="mx-auto w-full max-w-7xl lg:px-8"><div class="relative px-4 sm:px-8 lg:px-12"><div class="mx-auto max-w-2xl lg:max-w-5xl"><div class="xl:relative"><div class="mx-auto max-w-2xl"><article><header class="flex flex-col"><h1 class="mt-6 text-4xl font-bold tracking-tight text-zinc-800 sm:text-5xl dark:text-zinc-100">Kubernetes v1.35: Timbernetes (The World Tree Release)</h1><time dateTime="2025-12-17" class="order-first flex items-center text-base text-zinc-500 dark:text-zinc-400"><span>December 17, 2025</span></time></header><div class="mt-8 prose dark:prose-invert" data-mdx-content="true"><div><p><a href="https://kubernetes.io/blog/2025/12/17/kubernetes-v1-35-release/">Published by Kubernetes co-authored with Aakanksha Bhende, Arujjwal Negi, Chad M. Crowell, Swathi Rao</a></p>
<p>Similar to previous releases, the release of Kubernetes v1.35 introduces new stable, beta, and alpha features. The consistent delivery of high-quality releases underscores the strength of our development cycle and the vibrant support from our community.</p>
<p>This release consists of 60 enhancements, including 17 stable, 19 beta, and 22 alpha features.</p>
<p>There are also some <a href="https://kubernetes.io/blog/2025/12/17/kubernetes-v1-35-release/#deprecations-and-removals">deprecations and removals</a> in this release; make sure to read about those.</p>
<h2>Release theme and logo</h2>
<p><img src="https://kubernetes.io/blog/2025/12/17/kubernetes-v1-35-release/k8s-v1.35.png" alt="Kubernetes v1.35 Timbernetes logo: a storybook hex badge with a glowing world tree whose branches cradle Earth and a white Kubernetes wheel; three cheerful squirrels stand below—a wizard in a plum robe holding an LGTM scroll, a warrior with an axe and blue Kubernetes shield, and a lantern-carrying rogue in a navy cloak—on green grass above a gold ribbon reading World Tree Release, backed by soft mountains and cloud-swept sky"></p>
<p>Kubernetes v1.35 Timbernetes logo: a storybook hex badge with a glowing world tree whose branches cradle Earth and a white Kubernetes wheel; three cheerful squirrels stand below—a wizard in a plum robe holding an LGTM scroll, a warrior with an axe and blue Kubernetes shield, and a lantern-carrying rogue in a navy cloak—on green grass above a gold ribbon reading World Tree Release, backed by soft mountains and cloud-swept sky</p>
<p>2025 began in the shimmer of Octarine: The Color of Magic (v1.33) and rode the gusts Of Wind &#x26; Will (v1.34). We close the year with our hands on the World Tree, inspired by Yggdrasil, the tree of life that binds many realms. Like any great tree, Kubernetes grows ring by ring and release by release, shaped by the care of a global community.</p>
<p>At its center sits the Kubernetes wheel wrapped around the Earth, grounded by the resilient maintainers, contributors and users who keep showing up. Between day jobs, life changes, and steady open-source stewardship, they prune old APIs, graft new features and keep one of the world’s largest open source projects healthy.</p>
<p>Three squirrels guard the tree: a wizard holding the LGTM scroll for reviewers, a warrior with an axe and Kubernetes shield for the release crews who cut new branches, and a rogue with a lantern for the triagers who bring light to dark issue queues.</p>
<p>Together, they stand in for a much larger adventuring party. Kubernetes v1.35 adds another growth ring to the World Tree, a fresh cut shaped by many hands, many paths and a community whose branches reach higher as its roots grow deeper.</p>
<h2>Spotlight on key updates</h2>
<p>Kubernetes v1.35 is packed with new features and improvements. Here are a few select updates the Release Team would like to highlight!</p>
<h3>Stable: In-place update of Pod resources</h3>
<p>Kubernetes has graduated in-place updates for Pod resources to General Availability (GA). This feature allows users to adjust CPU and memory resources without restarting Pods or Containers. Previously, such modifications required recreating Pods, which could disrupt workloads, particularly for stateful or batch applications. Earlier Kubernetes releases allowed you to change only infrastructure resource settings (requests and limits) for existing Pods. The new in-place functionality allows for smoother, nondisruptive vertical scaling, improves efficiency, and can also simplify development.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/1287">KEP #1287</a> led by SIG Node.</p>
<h3>Beta: Pod certificates for workload identity and security</h3>
<p>Previously, delivering certificates to pods required external controllers (cert-manager, SPIFFE/SPIRE), CRD orchestration, and Secret management, with rotation handled by sidecars or init containers. Kubernetes v1.35 enables native workload identity with automated certificate rotation, drastically simplifying service mesh and zero-trust architectures.</p>
<p>Now, the <code>kubelet</code> generates keys, requests certificates via PodCertificateRequest, and writes credential bundles directly to the Pod's filesystem. The <code>kube-apiserver</code> enforces node restriction at admission time, eliminating the most common pitfall for third-party signers: accidentally violating node isolation boundaries. This enables pure mTLS flows with no bearer tokens in the issuance path.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/4317">KEP #4317</a> led by SIG Auth.</p>
<h3>Alpha: Node declared features before scheduling</h3>
<p>When control planes enable new features but nodes lag behind (permitted by Kubernetes skew policy), the scheduler can place pods requiring those features onto incompatible older nodes. The node-declaration features framework allows nodes to declare their supported Kubernetes features. With the new alpha feature enabled, a Node reports the features it supports, publishing this information to the control plane via a new <code>.status.declaredFeatures</code> field. Then, the <code>kube-scheduler</code>, admission controllers, and third-party components can use these declarations. For example, you can enforce scheduling and API validation constraints to ensure that Pods run only on compatible nodes.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/5328">KEP #5328</a> led by SIG Node.</p>
<h2>Features graduating to Stable</h2>
<p><em>This is a selection of some of the improvements that are now stable following the v1.35 release.</em></p>
<h3>PreferSameNode traffic distribution</h3>
<p>The <code>trafficDistribution</code> field for Services has been updated to provide more explicit control over traffic routing. A new option, <code>PreferSameNode</code>, has been introduced to let services strictly prioritize endpoints on the local node if available, falling back to remote endpoints otherwise.</p>
<p>Simultaneously, the existing <code>PreferClose</code> option has been renamed to <code>PreferSameZone</code>. This change makes the API self-explanatory by explicitly indicating that traffic is preferred within the current availability zone. While <code>PreferClose</code> is preserved for backward compatibility, <code>PreferSameZone</code> is now the standard for zonal routing, ensuring that both node-level and zone-level preferences are clearly distinguished.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/3015">KEP #3015</a> led by SIG Network.</p>
<h3>Job API managed-by mechanism</h3>
<p>The Job API now includes a <code>managedBy</code> field that allows an external controller to handle Job status synchronization. This feature, which graduates to stable in Kubernetes v1.35, is primarily driven by <a href="https://github.com/kubernetes-sigs/kueue/tree/main/keps/693-multikueue">MultiKueue</a>, a multi-cluster dispatching system where a Job created in a management cluster is mirrored and executed in a worker cluster, with status updates propagated back. To enable this workflow, the built-in Job controller must not act on a particular Job resource so that the Kueue controller can manage status updates instead.</p>
<p>The goal is to allow clean delegation of Job synchronization to another controller. It does not aim to pass custom parameters to that controller or modify CronJob concurrency policies.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/4368">KEP #4368</a> led by SIG Apps.</p>
<p>Historically, the Pod API lacked the <code>metadata.generation</code> field found in other Kubernetes objects such as Deployments. Because of this omission, controllers and users had no reliable way to verify whether the <code>kubelet</code> had actually processed the latest changes to a Pod's specification. This ambiguity was particularly problematic for features like <a href="https://kubernetes.io/blog/2025/12/17/kubernetes-v1-35-release/#stable-in-place-update-of-pod-resources">In-Place Pod Vertical Scaling</a>, where it was difficult to know exactly when a resource resize request had been enacted.</p>
<p>Kubernetes v1.33 added <code>.metadata.generation</code> fields for Pods, as an alpha feature. That field is now stable in the v1.35 Pod API, which means that every time a Pod's <code>spec</code> is updated, the <code>.metadata.generation</code> value is incremented. As part of this improvement, the Pod API also gained a <code>.status.observedGeneration</code> field, which reports the generation that the <code>kubelet</code> has successfully seen and processed. Pod conditions also each contain their own individual <code>observedGeneration</code> field that clients can report and / or observe.</p>
<p>Because this feature has graduated to stable in v1.35, it is available for all workloads.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/5067">KEP #5067</a> led by SIG Node.</p>
<h3>Configurable NUMA node limit for topology manager</h3>
<p>The <a href="https://kubernetes.io/docs/concepts/policy/node-resource-managers/">topology manager</a> historically used a hard-coded limit of 8 for the maximum number of NUMA nodes it can support, preventing state explosion during affinity calculation. (There's an important detail here; a <em>NUMA node</em> is not the same as a Node in the Kubernetes API.) This limit on the number of NUMA nodes prevented Kubernetes from fully utilizing modern high-end servers, which increasingly feature CPU architectures with more than 8 NUMA nodes.</p>
<p>Kubernetes v1.31 introduced a new, <strong>beta</strong> <code>max-allowable-numa-nodes</code> option to the topology manager policy configuration. In Kubernetes v1.35, that option is stable. Cluster administrators who enable it can use servers with more than 8 NUMA nodes.</p>
<p>Although the configuration option is stable, the Kubernetes community is aware of the poor performance for large NUMA hosts, and there is a <a href="https://kep.k8s.io/5726">proposed enhancement</a> (KEP-5726) that aims to improve on it. You can learn more about this by reading <a href="https://kubernetes.io/docs/tasks/administer-cluster/topology-manager/">Control Topology Management Policies on a node</a>.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/4622">KEP #4622</a> led by SIG Node.</p>
<h2>New features in Beta</h2>
<p><em>This is a selection of some of the improvements that are now beta following the v1.35 release.</em></p>
<p>Accessing node topology information, such as region and zone, from within a Pod has typically required querying the Kubernetes API server. While functional, this approach creates complexity and security risks by necessitating broad RBAC permissions or sidecar containers just to retrieve infrastructure metadata. Kubernetes v1.35 promotes the capability to expose node topology labels directly via the Downward API to beta.</p>
<p>The <code>kubelet</code> can now inject standard topology labels, such as <code>topology.kubernetes.io/zone</code> and <code>topology.kubernetes.io/region</code>, into Pods as environment variables or projected volume files. The primary benefit is a safer and more efficient way for workloads to be topology-aware. This allows applications to natively adapt to their availability zone or region without dependencies on the API server, strengthening security by upholding the principle of least privilege and simplifying cluster configuration.</p>
<p><strong>Note:</strong> Kubernetes now injects available topology labels to every Pod so that they can be used as inputs to the <a href="https://kubernetes.io/docs/concepts/workloads/pods/downward-api/">downward API</a>. With the v1.35 upgrade, most cluster administrators will see several new labels added to each Pod; this is expected as part of the design.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/4742">KEP #4742</a> led by SIG Node.</p>
<h3>Native support for storage version migration</h3>
<p>In Kubernetes v1.35, the native support for storage version migration graduates to beta and is enabled by default. This move integrates the migration logic directly into the core Kubernetes control plane ("in-tree"), eliminating the dependency on external tools.</p>
<p>Historically, administrators relied on manual "read/write loops"—often piping <code>kubectl get</code> into <code>kubectl replace—to</code> update schemas or re-encrypt data at rest. This method was inefficient and prone to conflicts, especially for large resources like Secrets. With this release, the built-in controller automatically handles update conflicts and consistency tokens, providing a safe, streamlined, and reliable way to ensure stored data remains current with minimal operational overhead.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/4192">KEP #4192</a> led by SIG API Machinery.</p>
<h3>Mutable Volume attach limits</h3>
<p>A CSI (Container Storage Interface) driver is a Kubernetes plugin that provides a consistent way for storage systems to be exposed to containerized workloads. The <code>CSINode</code> object records details about all CSI drivers installed on a node. However, a mismatch can arise between the reported and actual attachment capacity on nodes. When volume slots are consumed after a CSI driver starts up, the <code>kube-scheduler</code> may assign stateful pods to nodes without sufficient capacity, ultimately getting stuck in a <code>ContainerCreating</code> state.</p>
<p>Kubernetes v1.35 makes <code>CSINode.spec.drivers[*].allocatable.count</code> mutable so that a node’s available volume attachment capacity can be updated dynamically. It also allows CSI drivers to control how frequently the <code>allocatable.count</code> value is updated on all nodes by introducing a configurable refresh interval, defined through the <code>CSIDriver</code> object. Additionally, it automatically updates <code>CSINode.spec.drivers[*].allocatable.count</code> on detecting a failure in volume attachment due to insufficient capacity. Although this feature graduated to beta in v1.34 with the feature flag <code>MutableCSINodeAllocatableCount</code> disabled by default, it remains in beta for v1.35 to allow time for feedback, but the feature flag is enabled by default.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/4876">KEP #4876</a> led by SIG Storage.</p>
<h3>Opportunistic batching</h3>
<p>Historically, the Kubernetes scheduler processes pods sequentially with time complexity of <code>O(num pods × num nodes)</code>, which can result in redundant computation for compatible pods. This KEP introduces an opportunistic batching mechanism that aims to improve performance by identifying such compatible Pods via <code>Pod scheduling signature</code> and batching them together, allowing shared filtering and scoring results across them.</p>
<p>The pod scheduling signature ensures that two pods with the same signature are “the same” from a scheduling perspective. It takes into account not only the pod and node attributes, but also the other pods in the system and global data about the pod placement. This means that any pod with the given signature will get the same scores/feasibility results from any arbitrary set of nodes.</p>
<p>The batching mechanism consists of two operations that can be invoked whenever needed - <em>create</em> and <em>nominate</em>. Create leads to the creation of a new set of batch information from the scheduling results of Pods that have a valid signature. Nominate uses the batching information from create to set the nominated node name from a new Pod whose signature matches the canonical Pod’s signature.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/5598">KEP #5598</a> led by SIG Scheduling.</p>
<h3>maxUnavailable for StatefulSets</h3>
<p>A StatefulSet runs a group of Pods and maintains a sticky identity for each of those Pods. This is critical for stateful workloads requiring stable network identifiers or persistent storage. When a StatefulSet's <code>.spec.updateStrategy.&#x3C;type></code> is set to <code>RollingUpdate</code>, the StatefulSet controller will delete and recreate each Pod in the StatefulSet. It will proceed in the same order as Pod termination (from the largest ordinal to the smallest), updating each Pod one at a time.</p>
<p>Kubernetes v1.24 added a new <strong>alpha</strong> field to a StatefulSet's <code>rollingUpdate</code> configuration settings, called <code>maxUnavailable</code>. That field wasn't part of the Kubernetes API unless your cluster administrator explicitly opted in. In Kubernetes v1.35 that field is beta and is available by default. You can use it to define the maximum number of pods that can be unavailable during an update. This setting is most effective in combination with <code>.spec.podManagementPolicy</code> set to Parallel. You can set <code>maxUnavailable</code> as either a positive number (example: 2) or a percentage of the desired number of Pods (example: 10%). If this field is not specified, it will default to 1, to maintain the previous behavior of only updating one Pod at a time. This improvement allows stateful applications (that can tolerate more than one Pod being down) to finish updating faster.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/961">KEP #961</a> led by SIG Apps.</p>
<h3>Configurable credential plugin policy in kuberc</h3>
<p>The optional <a href="https://kubernetes.io/docs/reference/kubectl/kuberc/"><code>kuberc</code> file</a> is a way to separate server configurations and cluster credentials from user preferences without disrupting already running CI pipelines with unexpected outputs.</p>
<p>As part of the v1.35 release, <code>kuberc</code> gains additional functionality which allows users to configure credential plugin policy. This change introduces two fields <code>credentialPluginPolicy</code>, which allows or denies all plugins, and allows specifying a list of allowed plugins using <code>credentialPluginAllowlist</code>.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/3104">KEP #3104</a> as a cooperation between SIG Auth and SIG CLI.</p>
<h3>KYAML</h3>
<p>YAML is a human-readable format of data serialization. In Kubernetes, YAML files are used to define and configure resources, such as Pods, Services, and Deployments. However, complex YAML is difficult to read. YAML's significant whitespace requires careful attention to indentation and nesting, while its optional string-quoting can lead to unexpected type coercion (see: The Norway Bug). While JSON is an alternative, it lacks support for comments and has strict requirements for trailing commas and quoted keys.</p>
<p>KYAML is a safer and less ambiguous subset of YAML designed specifically for Kubernetes. Introduced as an opt-in alpha feature in v1.34, this feature graduated to beta in Kubernetes v1.35 and has been enabled by default. It can be disabled by setting the environment variable <code>KUBECTL_KYAML=false</code>.</p>
<p>KYAML addresses challenges pertaining to both YAML and JSON. All KYAML files are also valid YAML files. This means you can write KYAML and pass it as an input to any version of kubectl. This also means that you don’t need to write in strict KYAML for the input to be parsed.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/5295">KEP #5295</a> led by SIG CLI.</p>
<h3>Configurable tolerance for HorizontalPodAutoscalers</h3>
<p>The Horizontal Pod Autoscaler (HPA) has historically relied on a fixed, global 10% tolerance for scaling actions. A drawback of this hardcoded value was that workloads requiring high sensitivity, such as those needing to scale on a 5% load increase, were often blocked from scaling, while others might oscillate unnecessarily.</p>
<p>With Kubernetes v1.35, the configurable tolerance feature graduates to beta and is enabled by default. This enhancement allows users to define a custom tolerance window on a per-resource basis within the HPA <code>behavior</code> field. By setting a specific tolerance (e.g., lowering it to 0.05 for 5%), operators gain precise control over autoscaling sensitivity, ensuring that critical workloads react quickly to small metric changes, without requiring cluster-wide configuration adjustments.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/4951">KEP #4951</a> led by SIG Autoscaling.</p>
<h3>Support for user namespaces in Pods</h3>
<p>Kubernetes is adding support for user namespaces, allowing pods to run with isolated user and group ID mappings instead of sharing host IDs. This means containers can operate as root internally while actually being mapped to an unprivileged user on the host, reducing the risk of privilege escalation in the event of a compromise. The feature improves pod-level security and makes it safer to run workloads that need root inside the container. Over time, support has expanded to both stateless and stateful Pods through id-mapped mounts.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/127">KEP #127</a> led by SIG Node.</p>
<h3>VolumeSource: OCI artifact and/or image</h3>
<p>When creating a Pod, you often need to provide data, binaries, or configuration files for your containers. This meant including the content into the main container image or using a custom init container to download and unpack files into an <code>emptyDir</code>. Both these approaches are still valid. Kubernetes v1.31 added support for the <code>image</code> volume type allowing Pods to declaratively pull and unpack OCI container image artifacts into a volume. This lets you package and deliver data-only artifacts such as configs, binaries, or machine learning models using standard OCI registry tools.</p>
<p>With this feature, you can fully separate your data from your container image and remove the need for extra init containers or startup scripts. The image volume type has been in beta since v1.33 and is enabled by default in v1.35. Please note that using this feature requires a compatible container runtime, such as containerd v2.1 or later.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/4639">KEP #4639</a> led by SIG Node.</p>
<h3>Enforced kubelet credential verification for cached images</h3>
<p>The <code>imagePullPolicy: IfNotPresent</code> setting currently allows a Pod to use a container image that is already cached on a node, even if the Pod itself does not possess the credentials to pull that image. A drawback of this behavior is that it creates a security vulnerability in multi-tenant clusters: if a Pod with valid credentials pulls a sensitive private image to a node, a subsequent unauthorized Pod on the same node can access that image simply by relying on the local cache.</p>
<p>This KEP introduces a mechanism where the <code>kubelet</code> enforces credential verification for cached images. Before allowing a Pod to use a locally cached image, the <code>kubelet</code> checks if the Pod has the valid credentials to pull it. This ensures that only authorized workloads can use private images, regardless of whether they are already present on the node, significantly hardening the security posture for shared clusters.</p>
<p>In Kubernetes v1.35, this feature has graduated to beta and is enabled by default. Users can still disable it by setting the <code>KubeletEnsureSecretPulledImages</code> feature gate to false. Additionally, the <code>imagePullCredentialsVerificationPolicy</code> flag allows operators to configure the desired security level, ranging from a mode that prioritizes backward compatibility to a strict enforcement mode that offers maximum security.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/2535">KEP #2535</a> led by SIG Node.</p>
<h3>Fine-grained Container restart rules</h3>
<p>Historically, the <code>restartPolicy</code> field was defined strictly at the Pod level, forcing the same behavior on all containers within a Pod. A drawback of this global setting was the lack of granularity for complex workloads, such as AI/ML training jobs. These often required <code>restartPolicy: Never</code> for the Pod to manage job completion, yet individual containers would benefit from in-place restarts for specific, retriable errors (like network glitches or GPU init failures).</p>
<p>Kubernetes v1.35 addresses this by enabling <code>restartPolicy</code> and <code>restartPolicyRules</code> within the container API itself. This allows users to define restart strategies for individual regular and init containers that operate independently of the Pod's overall policy. For example, a container can now be configured to restart automatically only if it exits with a specific error code, avoiding the expensive overhead of rescheduling the entire Pod for a transient failure.</p>
<p>In this release, the feature has graduated to beta and is enabled by default. Users can immediately leverage <code>restartPolicyRules</code> in their container specifications to optimize recovery times and resource utilization for long-running workloads, without altering the broader lifecycle logic of their Pods.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/5307">KEP #5307</a> led by SIG Node.</p>
<h3>CSI driver opt-in for service account tokens via secrets field</h3>
<p>Providing ServiceAccount tokens to Container Storage Interface (CSI) drivers has traditionally relied on injecting them into the <code>volume_context</code> field. This approach presents a significant security risk because <code>volume_context</code> is intended for non-sensitive configuration data and is frequently logged in plain text by drivers and debugging tools, potentially leaking credentials.</p>
<p>Kubernetes v1.35 introduces an opt-in mechanism for CSI drivers to receive ServiceAccount tokens via the dedicated secrets field in the NodePublishVolume request. Drivers can now enable this behavior by setting the <code>serviceAccountTokenInSecrets</code> field to true in their CSIDriver object, instructing the <code>kubelet</code> to populate the token securely.</p>
<p>The primary benefit is the prevention of accidental credential exposure in logs and error messages. This change ensures that sensitive workload identities are handled via the appropriate secure channels, aligning with best practices for secret management while maintaining backward compatibility for existing drivers.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/5538">KEP #5538</a> led by SIG Auth in cooperation with SIG Storage.</p>
<h3>Deployment status: count of terminating replicas</h3>
<p>Historically, the Deployment status provided details on available and updated replicas but lacked explicit visibility into Pods that were in the process of shutting down. A drawback of this omission was that users and controllers could not easily distinguish between a stable Deployment and one that still had Pods executing cleanup tasks or adhering to long grace periods.</p>
<p>Kubernetes v1.35 promotes the <code>terminatingReplicas</code> field within the Deployment status to beta. This field provides a count of Pods that have a deletion timestamp set but have not yet been removed from the system. This feature is a foundational step in a larger initiative to improve how Deployments handle Pod replacement, laying the groundwork for future policies regarding when to create new Pods during a rollout.</p>
<p>The primary benefit is improved observability for lifecycle management tools and operators. By exposing the number of terminating Pods, external systems can now make more informed decisions such as waiting for a complete shutdown before proceeding with subsequent tasks without needing to manually query and filter individual Pod lists.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/3973">KEP #3973</a> led by SIG Apps.</p>
<h2>New features in Alpha</h2>
<p><em>This is a selection of some of the improvements that are now alpha following the v1.35 release.</em></p>
<h3>Gang scheduling support in Kubernetes</h3>
<p>Scheduling interdependent workloads, such as AI/ML training jobs or HPC simulations, has traditionally been challenging because the default Kubernetes scheduler places Pods individually. This often leads to partial scheduling where some Pods start while others wait indefinitely for resources, resulting in deadlocks and wasted cluster capacity.</p>
<p>Kubernetes v1.35 introduces native support for so-called "gang scheduling" via the new Workload API and PodGroup concept. This feature implements an "all-or-nothing" scheduling strategy, ensuring that a defined group of Pods is scheduled only if the cluster has sufficient resources to accommodate the entire group simultaneously.</p>
<p>The primary benefit is improved reliability and efficiency for batch and parallel workloads. By preventing partial deployments, it eliminates resource deadlocks and ensures that expensive cluster capacity is utilized only when a complete job can run, significantly optimizing the orchestration of large-scale data processing tasks.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/4671">KEP #4671</a> led by SIG Scheduling.</p>
<h3>Constrained impersonation</h3>
<p>Historically, the <code>impersonate</code> verb in Kubernetes RBAC functioned on an all-or-nothing basis: once a user was authorized to impersonate a target identity, they gained all associated permissions. A drawback of this broad authorization was that it violated the principle of least privilege, preventing administrators from restricting impersonators to specific actions or resources.</p>
<p>Kubernetes v1.35 introduces a new alpha feature, constrained impersonation, which adds a secondary authorization check to the impersonation flow. When enabled via the <code>ConstrainedImpersonation</code> feature gate, the API server verifies not only the basic <code>impersonate</code> permission but also checks if the impersonator is authorized for the specific action using new verb prefixes (e.g., <code>impersonate-on:&#x3C;mode>:&#x3C;verb></code>). This allows administrators to define fine-grained policies—such as permitting a support engineer to impersonate a cluster admin solely to view logs, without granting full administrative access.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/5284">KEP #5284</a> led by SIG Auth.</p>
<h3>Flagz for Kubernetes components</h3>
<p>Verifying the runtime configuration of Kubernetes components, such as the API server or <code>kubelet</code>, has traditionally required privileged access to the host node or process arguments. To address this, the <code>/flagz</code> endpoint was introduced to expose command-line options via HTTP. However, its output was initially limited to plain text, making it difficult for automated tools to parse and validate configurations reliably.</p>
<p>In Kubernetes v1.35, the <code>/flagz</code> endpoint has been enhanced to support structured, machine-readable JSON output. Authorized users can now request a versioned JSON response using standard HTTP content negotiation, while the original plain text format remains available for human inspection. This update significantly improves observability and compliance workflows, allowing external systems to programmatically audit component configurations without fragile text parsing or direct infrastructure access.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/4828">KEP #4828</a> led by SIG Instrumentation.</p>
<h3>Statusz for Kubernetes components</h3>
<p>Troubleshooting Kubernetes components like the <code>kube-apiserver</code> or <code>kubelet</code> has traditionally involved parsing unstructured logs or text output, which is brittle and difficult to automate. While a basic <code>/statusz</code> endpoint existed previously, it lacked a standardized, machine-readable format, limiting its utility for external monitoring systems.</p>
<p>In Kubernetes v1.35, the <code>/statusz</code> endpoint has been enhanced to support structured, machine-readable JSON output. Authorized users can now request this format using standard HTTP content negotiation to retrieve precise status data—such as version information and health indicators—without relying on fragile text parsing. This improvement provides a reliable, consistent interface for automated debugging and observability tools across all core components.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/4827">KEP #4827</a> led by SIG Instrumentation.</p>
<h3>CCM: watch-based route controller reconciliation using informers</h3>
<p>Managing network routes within cloud environments has traditionally relied on the Cloud Controller Manager (CCM) periodically polling the cloud provider's API to verify and update route tables. This fixed-interval reconciliation approach can be inefficient, often generating a high volume of unnecessary API calls and introducing latency between a node state change and the corresponding route update.</p>
<p>For the Kubernetes v1.35 release, the cloud-controller-manager library introduces a watch-based reconciliation strategy for the route controller. Instead of relying on a timer, the controller now utilizes informers to watch for specific Node events, such as additions, deletions, or relevant field updates and triggers route synchronization only when a change actually occurs.</p>
<p>The primary benefit is a significant reduction in cloud provider API usage, which lowers the risk of hitting rate limits and reduces operational overhead. Additionally, this event-driven model improves the responsiveness of the cluster's networking layer by ensuring that route tables are updated immediately following changes in cluster topology.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/5237">KEP #5237</a> led by SIG Cloud Provider.</p>
<h3>Extended toleration operators for threshold-based placement</h3>
<p>Kubernetes v1.35 introduces SLA-aware scheduling by enabling workloads to express reliability requirements. The feature adds numeric comparison operators to tolerations, allowing pods to match or avoid nodes based on SLA-oriented taints such as service guarantees or fault-domain quality.</p>
<p>The primary benefit is enhancing the scheduler with more precise placement. Critical workloads can demand higher-SLA nodes, while lower priority workloads can opt into lower SLA ones. This improves utilization and reduces cost without compromising reliability.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/5471">KEP #5471</a> led by SIG Scheduling.</p>
<h3>Mutable container resources when Job is suspended</h3>
<p>Running batch workloads often involves trial and error with resource limits. Currently, the Job specification is immutable, meaning that if a Job fails due to an Out of Memory (OOM) error or insufficient CPU, the user cannot simply adjust the resources; they must delete the Job and create a new one, losing the execution history and status.</p>
<p>Kubernetes v1.35 introduces the capability to update resource requests and limits for Jobs that are in a suspended state. Enabled via the <code>MutableJobPodResourcesForSuspendedJobs</code> feature gate, this enhancement allows users to pause a failing Job, modify its Pod template with appropriate resource values, and then resume execution with the corrected configuration.</p>
<p>The primary benefit is a smoother recovery workflow for misconfigured jobs. By allowing in-place corrections during suspension, users can resolve resource bottlenecks without disrupting the Job's lifecycle identity or losing track of its completion status, significantly improving the developer experience for batch processing.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/5440">KEP #5440</a> led by SIG Apps.</p>
<h2>Other notable changes</h2>
<h3>Continued innovation in Dynamic Resource Allocation (DRA)</h3>
<p>The <a href="https://kep.k8s.io/4381">core functionality</a> was graduated to stable in v1.34, with the ability to turn it off. In v1.35 it is always enabled. Several alpha features have also been significantly improved and are ready for testing. We encourage users to provide feedback on these capabilities to help clear the path for their target promotion to beta in upcoming releases.</p>
<h4>Extended Resource Requests via DRA</h4>
<p>Several functional gaps compared to Extended Resource requests via Device Plugins were addressed, for example scoring and reuse of devices in init containers.</p>
<h4>Device Taints and Tolerations</h4>
<p>The new "None" effect can be used to report a problem without immediately affecting scheduling or running pod. DeviceTaintRule now provides status information about an ongoing eviction. The "None" effect can be used for a "dry run" before actually evicting pods:</p>
<ul>
<li>Create DeviceTaintRule with "effect: None".</li>
<li>Check the status to see how many pods would be evicted.</li>
<li>Replace "effect: None" with "effect: NoExecute".</li>
</ul>
<h4>Partitionable Devices</h4>
<p>Devices belonging to the same partitionable devices may now be defined in different ResourceSlices. You can read more in the <a href="https://kubernetes.io/docs/concepts/scheduling-eviction/dynamic-resource-allocation/#partitionable-devices">official documentation</a>.</p>
<h4>Consumable Capacity, Device Binding Conditions</h4>
<p>Several bugs were fixed and/or more tests added. You can learn more about <a href="https://kubernetes.io/docs/concepts/scheduling-eviction/dynamic-resource-allocation/#consumable-capacity">Consumable Capacity</a> and <a href="https://kubernetes.io/docs/concepts/scheduling-eviction/dynamic-resource-allocation/#device-binding-conditions">Binding Conditions</a> in the official documentation.</p>
<h3>Comparable resource version semantics</h3>
<p>Kubernetes v1.35 changes the way that clients are allowed to interpret <a href="https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions">resource versions</a>.</p>
<p>Before v1.35, the only supported comparison that clients could make was to check for string equality: if two resource versions were equal, they were the same. Clients could also provide a resource version to the API server and ask the control plane to do internal comparisons, such as streaming all events since a particular resource version.</p>
<p>In v1.35, all in-tree resource versions meet a new stricter definition: the values are a special form of decimal number. And, because they can be compared, clients can do their own operations to compare two different resource versions. For example, this means that a client reconnecting after a crash can detect when it has lost updates, as distinct from the case where there has been an update but no lost changes in the meantime.</p>
<p>This change in semantics enables other important use cases such as <a href="https://kubernetes.io/docs/tasks/manage-kubernetes-objects/storage-version-migration/">storage version migration</a>, performance improvements to <em>informers</em> (a client helper concept), and controller reliability. All of those cases require knowing whether one resource version is newer than another.</p>
<p>This work was done as part of <a href="https://kep.k8s.io/5504">KEP #5504</a> led by SIG API Machinery.</p>
<h2>Graduations, deprecations, and removals in v1.35</h2>
<h3>Graduations to stable</h3>
<p>This lists all the features that graduated to stable (also known as <em>general availability</em>). For a full list of updates including new features and graduations from alpha to beta, see the release notes.</p>
<p>This release includes a total of 15 enhancements promoted to stable:</p>
<ul>
<li><a href="https://kep.k8s.io/4540">Add CPUManager policy option to restrict reservedSystemCPUs to system daemons and interrupt processing</a></li>
<li><a href="https://kep.k8s.io/5067">Pod Generation</a></li>
<li><a href="https://kep.k8s.io/5468">Invariant Testing</a></li>
<li><a href="https://kep.k8s.io/1287">In-Place Update of Pod Resources</a></li>
<li><a href="https://kep.k8s.io/3619">Fine-grained SupplementalGroups control</a></li>
<li><a href="https://kep.k8s.io/3983">Add support for a drop-in kubelet configuration directory</a></li>
<li><a href="https://kep.k8s.io/5589">Remove gogo protobuf dependency for Kubernetes API types</a></li>
<li><a href="https://kep.k8s.io/4210">kubelet image GC after a maximum age</a></li>
<li><a href="https://kep.k8s.io/3673">Kubelet limit of Parallel Image Pulls</a></li>
<li><a href="https://kep.k8s.io/4622">Add a TopologyManager policy option for MaxAllowableNUMANodes</a></li>
<li><a href="https://kep.k8s.io/859">Include kubectl command metadata in http request headers</a></li>
<li><a href="https://kep.k8s.io/3015">PreferSameNode Traffic Distribution (formerly PreferLocal traffic policy / Node-level topology)</a></li>
<li><a href="https://kep.k8s.io/4368">Job API managed-by mechanism</a></li>
<li><a href="https://kep.k8s.io/4006">Transition from SPDY to WebSockets</a></li>
</ul>
<h3>Deprecations, removals and community updates</h3>
<p>As Kubernetes develops and matures, features may be deprecated, removed, or replaced with better ones to improve the project's overall health. See the Kubernetes <a href="https://kubernetes.io/docs/reference/using-api/deprecation-policy/">deprecation and removal policy</a> for more details on this process. Kubernetes v1.35 includes a couple of deprecations.</p>
<h4>Ingress NGINX retirement</h4>
<p>For years, the Ingress NGINX controller has been a popular choice for routing traffic into Kubernetes clusters. It was flexible, widely adopted, and served as the standard entry point for countless applications.</p>
<p>However, maintaining the project has become unsustainable. With a severe shortage of maintainers and mounting technical debt, the community recently made the difficult decision to retire it. This isn't strictly part of the v1.35 release, but it's such an important change that we wanted to highlight it here.</p>
<p>Consequently, the Kubernetes project announced that Ingress NGINX will receive only best-effort maintenance until <strong>March 2026</strong>. After this date, it will be archived with no further updates. The recommended path forward is to migrate to the <a href="https://gateway-api.sigs.k8s.io/">Gateway API</a>, which offers a more modern, secure, and extensible standard for traffic management.</p>
<p>You can find more in the <a href="https://kubernetes.io/blog/2025/11/11/ingress-nginx-retirement/">official blog post</a>.</p>
<h4>Removal of cgroup v1 support</h4>
<p>When it comes to managing resources on Linux nodes, Kubernetes has historically relied on cgroups (control groups). While the original cgroup v1 was functional, it was often inconsistent and limited. That is why Kubernetes introduced support for cgroup v2 back in v1.25, offering a much cleaner, unified hierarchy and better resource isolation.</p>
<p>Because cgroup v2 is now the modern standard, Kubernetes is ready to retire the legacy cgroup v1 support in v1.35. This is an important notice for cluster administrators: if you are still running nodes on older Linux distributions that don't support cgroup v2, your <code>kubelet</code> will fail to start. To avoid downtime, you will need to migrate those nodes to systems where cgroup v2 is enabled.</p>
<p>To learn more, read <a href="https://kubernetes.io/docs/concepts/architecture/cgroups/">about cgroup v2</a>;<br>
you can also track the switchover work via <a href="https://kep.k8s.io/5573">KEP-5573: Remove cgroup v1 support</a>.</p>
<h4>Deprecation of ipvs mode in kube-proxy</h4>
<p>Years ago, Kubernetes adopted the <a href="https://kubernetes.io/docs/reference/networking/virtual-ips/#proxy-mode-ipvs"><code>ipvs</code></a> mode in <code>kube-proxy</code> to provide faster load balancing than the standard <a href="https://kubernetes.io/docs/reference/networking/virtual-ips/#proxy-mode-iptables"><code>iptables</code></a>. While it offered a performance boost, keeping it in sync with evolving networking requirements created too much technical debt and complexity.</p>
<p>Because of this maintenance burden, Kubernetes v1.35 deprecates <code>ipvs</code> mode. Although the mode remains available in this release, <code>kube-proxy</code> will now emit a warning on startup when configured to use it. The goal is to streamline the codebase and focus on modern standards. For Linux nodes, you should begin transitioning to <a href="https://kubernetes.io/docs/reference/networking/virtual-ips/#proxy-mode-nftables"><code>nftables</code></a>, which is now the recommended replacement.</p>
<p>You can find more in <a href="https://kep.k8s.io/5495">KEP-5495: Deprecate ipvs mode in kube-proxy</a>.</p>
<h4>Final call for containerd v1.X</h4>
<p>While Kubernetes v1.35 still supports containerd 1.7 and other LTS releases, this is the final version with such support. The SIG Node community has designated v1.35 as the last release to support the containerd v1.X series.</p>
<p>This serves as an important reminder: before upgrading to the next Kubernetes version, you must switch to containerd 2.0 or later. To help identify which nodes need attention, you can monitor the <code>kubelet_cri_losing_support</code> metric within your cluster.</p>
<p>You can find more in the <a href="https://kubernetes.io/blog/2025/09/12/kubernetes-v1-34-cri-cgroup-driver-lookup-now-ga/#announcement-kubernetes-is-deprecating-containerd-v1-y-support">official blog post</a> or in <a href="https://kep.k8s.io/4033">KEP-4033: Discover cgroup driver from CRI</a>.</p>
<h4>Improved Pod stability during kubelet restarts</h4>
<p>Previously, restarting the <code>kubelet</code> service often caused a temporary disruption in Pod status. During a restart, the kubelet would reset container states, causing healthy Pods to be marked as <code>NotReady</code> and removed from load balancers, even if the application itself was still running correctly.</p>
<p>To address this reliability issue, this behavior has been corrected to ensure seamless node maintenance. The <code>kubelet</code> now properly restores the state of existing containers from the runtime upon startup. This ensures that your workloads remain <code>Ready</code> and traffic continues to flow uninterrupted during <code>kubelet</code> restarts or upgrades.</p>
<p>You can find more in <a href="https://kep.k8s.io/4871">KEP-4781: Fix inconsistent container ready state after kubelet restart</a>.</p>
<h2>Release notes</h2>
<p>Check out the full details of the Kubernetes v1.35 release in our <a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.35.md">release notes</a>.</p>
<h2>Availability</h2>
<p>Kubernetes v1.35 is available for download on or on the <a href="https://kubernetes.io/releases/download/">Kubernetes download page</a>.</p>
<p>To get started with Kubernetes, check out these <a href="https://kubernetes.io/docs/tutorials/">interactive tutorials</a> or run local Kubernetes clusters using <a href="https://minikube.sigs.k8s.io/">minikube</a>. You can also easily install v1.35 using <a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/">kubeadm</a>.</p>
<h2>Release team</h2>
<p>Kubernetes is only possible with the support, commitment, and hard work of its community. Each release team is made up of dedicated community volunteers who work together to build the many pieces that make up the Kubernetes releases you rely on. This requires the specialized skills of people from all corners of our community, from the code itself to its documentation and project management.</p>
<p><a href="https://github.com/cncf/memorials/blob/main/han-kang.md">We honor the memory of Han Kang</a>, a long-time contributor and respected engineer whose technical excellence and infectious enthusiasm left a lasting impact on the Kubernetes community. Han was a significant force within SIG Instrumentation and SIG API Machinery, earning a <a href="https://www.kubernetes.dev/community/awards/2021/">2021 Kubernetes Contributor Award</a> for his critical work and sustained commitment to the project's core stability. Beyond his technical contributions, Han was deeply admired for his generosity as a mentor and his passion for building connections among people. He was known for "opening doors" for others, whether guiding new contributors through their first pull requests or supporting colleagues with patience and kindness. Han’s legacy lives on through the engineers he inspired, the robust systems he helped build, and the warm, collaborative spirit he fostered within the cloud native ecosystem.</p>
<p>We would like to thank the entire <a href="https://github.com/kubernetes/sig-release/blob/master/releases/release-1.35/release-team.md">Release Team</a> for the hours spent hard at work to deliver the Kubernetes v1.35 release to our community. The Release Team's membership ranges from first-time shadows to returning team leads with experience forged over several release cycles. We are incredibly grateful to our Release Lead, <a href="https://github.com/drewhagen">Drew Hagen</a>, whose hands-on guidance and vibrant energy not only navigated us through complex challenges but also fueled the community spirit behind this successful release.</p>
<h2>Project velocity</h2>
<p>The CNCF K8s <a href="https://k8s.devstats.cncf.io/d/11/companies-contributing-in-repository-groups?orgId=1&#x26;var-period=m&#x26;var-repogroup_name=All">DevStats</a> project aggregates a number of interesting data points related to the velocity of Kubernetes and various sub-projects. This includes everything from individual contributions to the number of companies that are contributing and is an illustration of the depth and breadth of effort that goes into evolving this ecosystem.</p>
<p>During the v1.35 release cycle, which spanned 14 weeks from 15th September 2025 to 17th December 2025, Kubernetes received contributions from as many as 85 different companies and 419 individuals. In the wider cloud native ecosystem, the figure goes up to 281 companies, counting 1769 total contributors.</p>
<p>Note that "contribution" counts when someone makes a commit, code review, comment, creates an issue or PR, reviews a PR (including blogs and documentation) or comments on issues and PRs.<br>
If you are interested in contributing, visit <a href="https://www.kubernetes.dev/docs/guide/#getting-started">Getting Started</a> on our contributor website.</p>
<p>Sources for this data:</p>
<ul>
<li><a href="https://k8s.devstats.cncf.io/d/11/companies-contributing-in-repository-groups?orgId=1&#x26;from=1757890800000&#x26;to=1765929599000&#x26;var-period=d28&#x26;var-repogroup_name=Kubernetes&#x26;var-repo_name=kubernetes%2Fkubernetes">Companies contributing to Kubernetes</a></li>
<li><a href="https://k8s.devstats.cncf.io/d/11/companies-contributing-in-repository-groups?orgId=1&#x26;from=1757890800000&#x26;to=1765929599000&#x26;var-period=d28&#x26;var-repogroup_name=All&#x26;var-repo_name=kubernetes%2Fkubernetes">Overall ecosystem contributions</a></li>
</ul>
<h2>Events update</h2>
<p>Explore upcoming Kubernetes and cloud native events, including KubeCon + CloudNativeCon, KCD, and other notable conferences worldwide. Stay informed and get involved with the Kubernetes community!</p>
<p><strong>February 2026</strong></p>
<ul>
<li><a href="https://www.kcddelhi.com/"><strong>KCD - Kubernetes Community Days: New Delhi</strong></a>: Feb 21, 2026 | New Delhi, India</li>
<li><a href="https://community.cncf.io/events/details/cncf-kcd-guadalajara-presents-kcd-guadalajara-open-source-contributor-summit/cohost-kcd-guadalajara"><strong>KCD - Kubernetes Community Days: Guadalajara</strong></a>: Feb 23, 2026 | Guadalajara, Mexico</li>
</ul>
<p><strong>March 2026</strong></p>
<ul>
<li><a href="https://events.linuxfoundation.org/kubecon-cloudnativecon-europe/"><strong>KubeCon + CloudNativeCon Europe 2026</strong></a>: Mar 23-26, 2026 | Amsterdam, Netherlands</li>
</ul>
<p><strong>May 2026</strong></p>
<ul>
<li><a href="https://community.cncf.io/events/details/cncf-kcd-toronto-presents-kcd-toronto-canada-2026/"><strong>KCD - Kubernetes Community Days: Toronto</strong></a>: May 13, 2026 | Toronto, Canada</li>
<li><a href="https://cloudnativefinland.org/kcd-helsinki-2026/"><strong>KCD - Kubernetes Community Days: Helsinki</strong></a>: May 20, 2026 | Helsinki, Finland</li>
</ul>
<p><strong>June 2026</strong></p>
<ul>
<li><a href="https://events.linuxfoundation.org/kubecon-cloudnativecon-china/"><strong>KubeCon + CloudNativeCon China 2026</strong></a>: Jun 10-11, 2026 | Hong Kong</li>
<li><a href="https://events.linuxfoundation.org/kubecon-cloudnativecon-india/"><strong>KubeCon + CloudNativeCon India 2026</strong></a>: Jun 18-19, 2026 | Mumbai, India</li>
<li><a href="https://community.cncf.io/kcd-kuala-lumpur-2026/"><strong>KCD - Kubernetes Community Days: Kuala Lumpur</strong></a>: Jun 27, 2026 | Kuala Lumpur, Malaysia</li>
</ul>
<p><strong>July 2026</strong></p>
<ul>
<li><a href="https://events.linuxfoundation.org/kubecon-cloudnativecon-japan/"><strong>KubeCon + CloudNativeCon Japan 2026</strong></a>: Jul 29-30, 2026 | Yokohama, Japan</li>
</ul>
<p>You can find the latest event details <a href="https://community.cncf.io/events/#/list">here</a>.</p>
<h2>Upcoming release webinar</h2>
<p>Join members of the Kubernetes v1.35 Release Team on <strong>Wednesday, January 14, 2026, at 5:00 PM (UTC)</strong> to learn about the release highlights of this release. For more information and registration, visit the <a href="https://community.cncf.io/events/details/cncf-cncf-online-programs-presents-cloud-native-live-kubernetes-v135-release/">event page</a> on the CNCF Online Programs site.</p>
<h2>Get involved</h2>
<p>The simplest way to get involved with Kubernetes is by joining one of the many <a href="https://github.com/kubernetes/community/blob/master/sig-list.md">Special Interest Groups</a> (SIGs) that align with your interests. Have something you’d like to broadcast to the Kubernetes community? Share your voice at our weekly <a href="https://github.com/kubernetes/community/tree/master/communication">community meeting</a>, and through the channels below. Thank you for your continued feedback and support.</p>
<ul>
<li>Follow us on Bluesky <a href="https://bsky.app/profile/kubernetes.io">@Kubernetesio</a> for the latest updates</li>
<li>Join the community discussion on <a href="https://discuss.kubernetes.io/">Discuss</a></li>
<li>Join the community on <a href="http://slack.k8s.io/">Slack</a></li>
<li>Post questions (or answer questions) on <a href="http://stackoverflow.com/questions/tagged/kubernetes">Stack Overflow</a></li>
<li>Share your Kubernetes <a href="https://docs.google.com/a/linuxfoundation.org/forms/d/e/1FAIpQLScuI7Ye3VQHQTwBASrgkjQDSS5TP0g3AXfFhwSM9YpHgxRKFA/viewform">story</a></li>
<li>Read more about what’s happening with Kubernetes on the <a href="https://kubernetes.io/blog/">blog</a></li>
<li>Learn more about the <a href="https://github.com/kubernetes/sig-release/tree/master/release-team">Kubernetes Release Team</a></li>
</ul>
</div></div></article></div></div></div></div></div></div></main><footer class="mt-32 flex-none"><div class="sm:px-8"><div class="mx-auto w-full max-w-7xl lg:px-8"><div class="border-t border-zinc-100 pb-16 pt-10 dark:border-zinc-700/40"><div class="relative px-4 sm:px-8 lg:px-12"><div class="mx-auto max-w-2xl lg:max-w-5xl"><div class="flex flex-col items-center justify-between gap-6 sm:flex-row"><div class="flex flex-wrap justify-center gap-x-6 gap-y-1 text-sm font-medium text-zinc-800 dark:text-zinc-200"><a class="transition hover:text-teal-500 dark:hover:text-teal-400" href="/about-me/">About</a><a class="transition hover:text-teal-500 dark:hover:text-teal-400" href="/projects/">Projects</a><a class="transition hover:text-teal-500 dark:hover:text-teal-400" href="/speaking/">Speaking</a></div><p class="text-sm text-zinc-500 dark:text-zinc-400">© <!-- -->2026<!-- --> Graziano Casto. All rights reserved.</p></div></div></div></div></div></div></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"article":{"title":"Kubernetes v1.35: Timbernetes (The World Tree Release)","date":"2025-12-17","slug":"kubernetes-v135-announcement"},"children":"\u003cp\u003e\u003ca href=\"https://kubernetes.io/blog/2025/12/17/kubernetes-v1-35-release/\"\u003ePublished by Kubernetes co-authored with Aakanksha Bhende, Arujjwal Negi, Chad M. Crowell, Swathi Rao\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eSimilar to previous releases, the release of Kubernetes v1.35 introduces new stable, beta, and alpha features. The consistent delivery of high-quality releases underscores the strength of our development cycle and the vibrant support from our community.\u003c/p\u003e\n\u003cp\u003eThis release consists of 60 enhancements, including 17 stable, 19 beta, and 22 alpha features.\u003c/p\u003e\n\u003cp\u003eThere are also some \u003ca href=\"https://kubernetes.io/blog/2025/12/17/kubernetes-v1-35-release/#deprecations-and-removals\"\u003edeprecations and removals\u003c/a\u003e in this release; make sure to read about those.\u003c/p\u003e\n\u003ch2\u003eRelease theme and logo\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"https://kubernetes.io/blog/2025/12/17/kubernetes-v1-35-release/k8s-v1.35.png\" alt=\"Kubernetes v1.35 Timbernetes logo: a storybook hex badge with a glowing world tree whose branches cradle Earth and a white Kubernetes wheel; three cheerful squirrels stand below—a wizard in a plum robe holding an LGTM scroll, a warrior with an axe and blue Kubernetes shield, and a lantern-carrying rogue in a navy cloak—on green grass above a gold ribbon reading World Tree Release, backed by soft mountains and cloud-swept sky\"\u003e\u003c/p\u003e\n\u003cp\u003eKubernetes v1.35 Timbernetes logo: a storybook hex badge with a glowing world tree whose branches cradle Earth and a white Kubernetes wheel; three cheerful squirrels stand below—a wizard in a plum robe holding an LGTM scroll, a warrior with an axe and blue Kubernetes shield, and a lantern-carrying rogue in a navy cloak—on green grass above a gold ribbon reading World Tree Release, backed by soft mountains and cloud-swept sky\u003c/p\u003e\n\u003cp\u003e2025 began in the shimmer of Octarine: The Color of Magic (v1.33) and rode the gusts Of Wind \u0026#x26; Will (v1.34). We close the year with our hands on the World Tree, inspired by Yggdrasil, the tree of life that binds many realms. Like any great tree, Kubernetes grows ring by ring and release by release, shaped by the care of a global community.\u003c/p\u003e\n\u003cp\u003eAt its center sits the Kubernetes wheel wrapped around the Earth, grounded by the resilient maintainers, contributors and users who keep showing up. Between day jobs, life changes, and steady open-source stewardship, they prune old APIs, graft new features and keep one of the world’s largest open source projects healthy.\u003c/p\u003e\n\u003cp\u003eThree squirrels guard the tree: a wizard holding the LGTM scroll for reviewers, a warrior with an axe and Kubernetes shield for the release crews who cut new branches, and a rogue with a lantern for the triagers who bring light to dark issue queues.\u003c/p\u003e\n\u003cp\u003eTogether, they stand in for a much larger adventuring party. Kubernetes v1.35 adds another growth ring to the World Tree, a fresh cut shaped by many hands, many paths and a community whose branches reach higher as its roots grow deeper.\u003c/p\u003e\n\u003ch2\u003eSpotlight on key updates\u003c/h2\u003e\n\u003cp\u003eKubernetes v1.35 is packed with new features and improvements. Here are a few select updates the Release Team would like to highlight!\u003c/p\u003e\n\u003ch3\u003eStable: In-place update of Pod resources\u003c/h3\u003e\n\u003cp\u003eKubernetes has graduated in-place updates for Pod resources to General Availability (GA). This feature allows users to adjust CPU and memory resources without restarting Pods or Containers. Previously, such modifications required recreating Pods, which could disrupt workloads, particularly for stateful or batch applications. Earlier Kubernetes releases allowed you to change only infrastructure resource settings (requests and limits) for existing Pods. The new in-place functionality allows for smoother, nondisruptive vertical scaling, improves efficiency, and can also simplify development.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/1287\"\u003eKEP #1287\u003c/a\u003e led by SIG Node.\u003c/p\u003e\n\u003ch3\u003eBeta: Pod certificates for workload identity and security\u003c/h3\u003e\n\u003cp\u003ePreviously, delivering certificates to pods required external controllers (cert-manager, SPIFFE/SPIRE), CRD orchestration, and Secret management, with rotation handled by sidecars or init containers. Kubernetes v1.35 enables native workload identity with automated certificate rotation, drastically simplifying service mesh and zero-trust architectures.\u003c/p\u003e\n\u003cp\u003eNow, the \u003ccode\u003ekubelet\u003c/code\u003e generates keys, requests certificates via PodCertificateRequest, and writes credential bundles directly to the Pod's filesystem. The \u003ccode\u003ekube-apiserver\u003c/code\u003e enforces node restriction at admission time, eliminating the most common pitfall for third-party signers: accidentally violating node isolation boundaries. This enables pure mTLS flows with no bearer tokens in the issuance path.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/4317\"\u003eKEP #4317\u003c/a\u003e led by SIG Auth.\u003c/p\u003e\n\u003ch3\u003eAlpha: Node declared features before scheduling\u003c/h3\u003e\n\u003cp\u003eWhen control planes enable new features but nodes lag behind (permitted by Kubernetes skew policy), the scheduler can place pods requiring those features onto incompatible older nodes. The node-declaration features framework allows nodes to declare their supported Kubernetes features. With the new alpha feature enabled, a Node reports the features it supports, publishing this information to the control plane via a new \u003ccode\u003e.status.declaredFeatures\u003c/code\u003e field. Then, the \u003ccode\u003ekube-scheduler\u003c/code\u003e, admission controllers, and third-party components can use these declarations. For example, you can enforce scheduling and API validation constraints to ensure that Pods run only on compatible nodes.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/5328\"\u003eKEP #5328\u003c/a\u003e led by SIG Node.\u003c/p\u003e\n\u003ch2\u003eFeatures graduating to Stable\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eThis is a selection of some of the improvements that are now stable following the v1.35 release.\u003c/em\u003e\u003c/p\u003e\n\u003ch3\u003ePreferSameNode traffic distribution\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003etrafficDistribution\u003c/code\u003e field for Services has been updated to provide more explicit control over traffic routing. A new option, \u003ccode\u003ePreferSameNode\u003c/code\u003e, has been introduced to let services strictly prioritize endpoints on the local node if available, falling back to remote endpoints otherwise.\u003c/p\u003e\n\u003cp\u003eSimultaneously, the existing \u003ccode\u003ePreferClose\u003c/code\u003e option has been renamed to \u003ccode\u003ePreferSameZone\u003c/code\u003e. This change makes the API self-explanatory by explicitly indicating that traffic is preferred within the current availability zone. While \u003ccode\u003ePreferClose\u003c/code\u003e is preserved for backward compatibility, \u003ccode\u003ePreferSameZone\u003c/code\u003e is now the standard for zonal routing, ensuring that both node-level and zone-level preferences are clearly distinguished.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/3015\"\u003eKEP #3015\u003c/a\u003e led by SIG Network.\u003c/p\u003e\n\u003ch3\u003eJob API managed-by mechanism\u003c/h3\u003e\n\u003cp\u003eThe Job API now includes a \u003ccode\u003emanagedBy\u003c/code\u003e field that allows an external controller to handle Job status synchronization. This feature, which graduates to stable in Kubernetes v1.35, is primarily driven by \u003ca href=\"https://github.com/kubernetes-sigs/kueue/tree/main/keps/693-multikueue\"\u003eMultiKueue\u003c/a\u003e, a multi-cluster dispatching system where a Job created in a management cluster is mirrored and executed in a worker cluster, with status updates propagated back. To enable this workflow, the built-in Job controller must not act on a particular Job resource so that the Kueue controller can manage status updates instead.\u003c/p\u003e\n\u003cp\u003eThe goal is to allow clean delegation of Job synchronization to another controller. It does not aim to pass custom parameters to that controller or modify CronJob concurrency policies.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/4368\"\u003eKEP #4368\u003c/a\u003e led by SIG Apps.\u003c/p\u003e\n\u003cp\u003eHistorically, the Pod API lacked the \u003ccode\u003emetadata.generation\u003c/code\u003e field found in other Kubernetes objects such as Deployments. Because of this omission, controllers and users had no reliable way to verify whether the \u003ccode\u003ekubelet\u003c/code\u003e had actually processed the latest changes to a Pod's specification. This ambiguity was particularly problematic for features like \u003ca href=\"https://kubernetes.io/blog/2025/12/17/kubernetes-v1-35-release/#stable-in-place-update-of-pod-resources\"\u003eIn-Place Pod Vertical Scaling\u003c/a\u003e, where it was difficult to know exactly when a resource resize request had been enacted.\u003c/p\u003e\n\u003cp\u003eKubernetes v1.33 added \u003ccode\u003e.metadata.generation\u003c/code\u003e fields for Pods, as an alpha feature. That field is now stable in the v1.35 Pod API, which means that every time a Pod's \u003ccode\u003espec\u003c/code\u003e is updated, the \u003ccode\u003e.metadata.generation\u003c/code\u003e value is incremented. As part of this improvement, the Pod API also gained a \u003ccode\u003e.status.observedGeneration\u003c/code\u003e field, which reports the generation that the \u003ccode\u003ekubelet\u003c/code\u003e has successfully seen and processed. Pod conditions also each contain their own individual \u003ccode\u003eobservedGeneration\u003c/code\u003e field that clients can report and / or observe.\u003c/p\u003e\n\u003cp\u003eBecause this feature has graduated to stable in v1.35, it is available for all workloads.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/5067\"\u003eKEP #5067\u003c/a\u003e led by SIG Node.\u003c/p\u003e\n\u003ch3\u003eConfigurable NUMA node limit for topology manager\u003c/h3\u003e\n\u003cp\u003eThe \u003ca href=\"https://kubernetes.io/docs/concepts/policy/node-resource-managers/\"\u003etopology manager\u003c/a\u003e historically used a hard-coded limit of 8 for the maximum number of NUMA nodes it can support, preventing state explosion during affinity calculation. (There's an important detail here; a \u003cem\u003eNUMA node\u003c/em\u003e is not the same as a Node in the Kubernetes API.) This limit on the number of NUMA nodes prevented Kubernetes from fully utilizing modern high-end servers, which increasingly feature CPU architectures with more than 8 NUMA nodes.\u003c/p\u003e\n\u003cp\u003eKubernetes v1.31 introduced a new, \u003cstrong\u003ebeta\u003c/strong\u003e \u003ccode\u003emax-allowable-numa-nodes\u003c/code\u003e option to the topology manager policy configuration. In Kubernetes v1.35, that option is stable. Cluster administrators who enable it can use servers with more than 8 NUMA nodes.\u003c/p\u003e\n\u003cp\u003eAlthough the configuration option is stable, the Kubernetes community is aware of the poor performance for large NUMA hosts, and there is a \u003ca href=\"https://kep.k8s.io/5726\"\u003eproposed enhancement\u003c/a\u003e (KEP-5726) that aims to improve on it. You can learn more about this by reading \u003ca href=\"https://kubernetes.io/docs/tasks/administer-cluster/topology-manager/\"\u003eControl Topology Management Policies on a node\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/4622\"\u003eKEP #4622\u003c/a\u003e led by SIG Node.\u003c/p\u003e\n\u003ch2\u003eNew features in Beta\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eThis is a selection of some of the improvements that are now beta following the v1.35 release.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eAccessing node topology information, such as region and zone, from within a Pod has typically required querying the Kubernetes API server. While functional, this approach creates complexity and security risks by necessitating broad RBAC permissions or sidecar containers just to retrieve infrastructure metadata. Kubernetes v1.35 promotes the capability to expose node topology labels directly via the Downward API to beta.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003ekubelet\u003c/code\u003e can now inject standard topology labels, such as \u003ccode\u003etopology.kubernetes.io/zone\u003c/code\u003e and \u003ccode\u003etopology.kubernetes.io/region\u003c/code\u003e, into Pods as environment variables or projected volume files. The primary benefit is a safer and more efficient way for workloads to be topology-aware. This allows applications to natively adapt to their availability zone or region without dependencies on the API server, strengthening security by upholding the principle of least privilege and simplifying cluster configuration.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e Kubernetes now injects available topology labels to every Pod so that they can be used as inputs to the \u003ca href=\"https://kubernetes.io/docs/concepts/workloads/pods/downward-api/\"\u003edownward API\u003c/a\u003e. With the v1.35 upgrade, most cluster administrators will see several new labels added to each Pod; this is expected as part of the design.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/4742\"\u003eKEP #4742\u003c/a\u003e led by SIG Node.\u003c/p\u003e\n\u003ch3\u003eNative support for storage version migration\u003c/h3\u003e\n\u003cp\u003eIn Kubernetes v1.35, the native support for storage version migration graduates to beta and is enabled by default. This move integrates the migration logic directly into the core Kubernetes control plane (\"in-tree\"), eliminating the dependency on external tools.\u003c/p\u003e\n\u003cp\u003eHistorically, administrators relied on manual \"read/write loops\"—often piping \u003ccode\u003ekubectl get\u003c/code\u003e into \u003ccode\u003ekubectl replace—to\u003c/code\u003e update schemas or re-encrypt data at rest. This method was inefficient and prone to conflicts, especially for large resources like Secrets. With this release, the built-in controller automatically handles update conflicts and consistency tokens, providing a safe, streamlined, and reliable way to ensure stored data remains current with minimal operational overhead.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/4192\"\u003eKEP #4192\u003c/a\u003e led by SIG API Machinery.\u003c/p\u003e\n\u003ch3\u003eMutable Volume attach limits\u003c/h3\u003e\n\u003cp\u003eA CSI (Container Storage Interface) driver is a Kubernetes plugin that provides a consistent way for storage systems to be exposed to containerized workloads. The \u003ccode\u003eCSINode\u003c/code\u003e object records details about all CSI drivers installed on a node. However, a mismatch can arise between the reported and actual attachment capacity on nodes. When volume slots are consumed after a CSI driver starts up, the \u003ccode\u003ekube-scheduler\u003c/code\u003e may assign stateful pods to nodes without sufficient capacity, ultimately getting stuck in a \u003ccode\u003eContainerCreating\u003c/code\u003e state.\u003c/p\u003e\n\u003cp\u003eKubernetes v1.35 makes \u003ccode\u003eCSINode.spec.drivers[*].allocatable.count\u003c/code\u003e mutable so that a node’s available volume attachment capacity can be updated dynamically. It also allows CSI drivers to control how frequently the \u003ccode\u003eallocatable.count\u003c/code\u003e value is updated on all nodes by introducing a configurable refresh interval, defined through the \u003ccode\u003eCSIDriver\u003c/code\u003e object. Additionally, it automatically updates \u003ccode\u003eCSINode.spec.drivers[*].allocatable.count\u003c/code\u003e on detecting a failure in volume attachment due to insufficient capacity. Although this feature graduated to beta in v1.34 with the feature flag \u003ccode\u003eMutableCSINodeAllocatableCount\u003c/code\u003e disabled by default, it remains in beta for v1.35 to allow time for feedback, but the feature flag is enabled by default.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/4876\"\u003eKEP #4876\u003c/a\u003e led by SIG Storage.\u003c/p\u003e\n\u003ch3\u003eOpportunistic batching\u003c/h3\u003e\n\u003cp\u003eHistorically, the Kubernetes scheduler processes pods sequentially with time complexity of \u003ccode\u003eO(num pods × num nodes)\u003c/code\u003e, which can result in redundant computation for compatible pods. This KEP introduces an opportunistic batching mechanism that aims to improve performance by identifying such compatible Pods via \u003ccode\u003ePod scheduling signature\u003c/code\u003e and batching them together, allowing shared filtering and scoring results across them.\u003c/p\u003e\n\u003cp\u003eThe pod scheduling signature ensures that two pods with the same signature are “the same” from a scheduling perspective. It takes into account not only the pod and node attributes, but also the other pods in the system and global data about the pod placement. This means that any pod with the given signature will get the same scores/feasibility results from any arbitrary set of nodes.\u003c/p\u003e\n\u003cp\u003eThe batching mechanism consists of two operations that can be invoked whenever needed - \u003cem\u003ecreate\u003c/em\u003e and \u003cem\u003enominate\u003c/em\u003e. Create leads to the creation of a new set of batch information from the scheduling results of Pods that have a valid signature. Nominate uses the batching information from create to set the nominated node name from a new Pod whose signature matches the canonical Pod’s signature.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/5598\"\u003eKEP #5598\u003c/a\u003e led by SIG Scheduling.\u003c/p\u003e\n\u003ch3\u003emaxUnavailable for StatefulSets\u003c/h3\u003e\n\u003cp\u003eA StatefulSet runs a group of Pods and maintains a sticky identity for each of those Pods. This is critical for stateful workloads requiring stable network identifiers or persistent storage. When a StatefulSet's \u003ccode\u003e.spec.updateStrategy.\u0026#x3C;type\u003e\u003c/code\u003e is set to \u003ccode\u003eRollingUpdate\u003c/code\u003e, the StatefulSet controller will delete and recreate each Pod in the StatefulSet. It will proceed in the same order as Pod termination (from the largest ordinal to the smallest), updating each Pod one at a time.\u003c/p\u003e\n\u003cp\u003eKubernetes v1.24 added a new \u003cstrong\u003ealpha\u003c/strong\u003e field to a StatefulSet's \u003ccode\u003erollingUpdate\u003c/code\u003e configuration settings, called \u003ccode\u003emaxUnavailable\u003c/code\u003e. That field wasn't part of the Kubernetes API unless your cluster administrator explicitly opted in. In Kubernetes v1.35 that field is beta and is available by default. You can use it to define the maximum number of pods that can be unavailable during an update. This setting is most effective in combination with \u003ccode\u003e.spec.podManagementPolicy\u003c/code\u003e set to Parallel. You can set \u003ccode\u003emaxUnavailable\u003c/code\u003e as either a positive number (example: 2) or a percentage of the desired number of Pods (example: 10%). If this field is not specified, it will default to 1, to maintain the previous behavior of only updating one Pod at a time. This improvement allows stateful applications (that can tolerate more than one Pod being down) to finish updating faster.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/961\"\u003eKEP #961\u003c/a\u003e led by SIG Apps.\u003c/p\u003e\n\u003ch3\u003eConfigurable credential plugin policy in kuberc\u003c/h3\u003e\n\u003cp\u003eThe optional \u003ca href=\"https://kubernetes.io/docs/reference/kubectl/kuberc/\"\u003e\u003ccode\u003ekuberc\u003c/code\u003e file\u003c/a\u003e is a way to separate server configurations and cluster credentials from user preferences without disrupting already running CI pipelines with unexpected outputs.\u003c/p\u003e\n\u003cp\u003eAs part of the v1.35 release, \u003ccode\u003ekuberc\u003c/code\u003e gains additional functionality which allows users to configure credential plugin policy. This change introduces two fields \u003ccode\u003ecredentialPluginPolicy\u003c/code\u003e, which allows or denies all plugins, and allows specifying a list of allowed plugins using \u003ccode\u003ecredentialPluginAllowlist\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/3104\"\u003eKEP #3104\u003c/a\u003e as a cooperation between SIG Auth and SIG CLI.\u003c/p\u003e\n\u003ch3\u003eKYAML\u003c/h3\u003e\n\u003cp\u003eYAML is a human-readable format of data serialization. In Kubernetes, YAML files are used to define and configure resources, such as Pods, Services, and Deployments. However, complex YAML is difficult to read. YAML's significant whitespace requires careful attention to indentation and nesting, while its optional string-quoting can lead to unexpected type coercion (see: The Norway Bug). While JSON is an alternative, it lacks support for comments and has strict requirements for trailing commas and quoted keys.\u003c/p\u003e\n\u003cp\u003eKYAML is a safer and less ambiguous subset of YAML designed specifically for Kubernetes. Introduced as an opt-in alpha feature in v1.34, this feature graduated to beta in Kubernetes v1.35 and has been enabled by default. It can be disabled by setting the environment variable \u003ccode\u003eKUBECTL_KYAML=false\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eKYAML addresses challenges pertaining to both YAML and JSON. All KYAML files are also valid YAML files. This means you can write KYAML and pass it as an input to any version of kubectl. This also means that you don’t need to write in strict KYAML for the input to be parsed.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/5295\"\u003eKEP #5295\u003c/a\u003e led by SIG CLI.\u003c/p\u003e\n\u003ch3\u003eConfigurable tolerance for HorizontalPodAutoscalers\u003c/h3\u003e\n\u003cp\u003eThe Horizontal Pod Autoscaler (HPA) has historically relied on a fixed, global 10% tolerance for scaling actions. A drawback of this hardcoded value was that workloads requiring high sensitivity, such as those needing to scale on a 5% load increase, were often blocked from scaling, while others might oscillate unnecessarily.\u003c/p\u003e\n\u003cp\u003eWith Kubernetes v1.35, the configurable tolerance feature graduates to beta and is enabled by default. This enhancement allows users to define a custom tolerance window on a per-resource basis within the HPA \u003ccode\u003ebehavior\u003c/code\u003e field. By setting a specific tolerance (e.g., lowering it to 0.05 for 5%), operators gain precise control over autoscaling sensitivity, ensuring that critical workloads react quickly to small metric changes, without requiring cluster-wide configuration adjustments.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/4951\"\u003eKEP #4951\u003c/a\u003e led by SIG Autoscaling.\u003c/p\u003e\n\u003ch3\u003eSupport for user namespaces in Pods\u003c/h3\u003e\n\u003cp\u003eKubernetes is adding support for user namespaces, allowing pods to run with isolated user and group ID mappings instead of sharing host IDs. This means containers can operate as root internally while actually being mapped to an unprivileged user on the host, reducing the risk of privilege escalation in the event of a compromise. The feature improves pod-level security and makes it safer to run workloads that need root inside the container. Over time, support has expanded to both stateless and stateful Pods through id-mapped mounts.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/127\"\u003eKEP #127\u003c/a\u003e led by SIG Node.\u003c/p\u003e\n\u003ch3\u003eVolumeSource: OCI artifact and/or image\u003c/h3\u003e\n\u003cp\u003eWhen creating a Pod, you often need to provide data, binaries, or configuration files for your containers. This meant including the content into the main container image or using a custom init container to download and unpack files into an \u003ccode\u003eemptyDir\u003c/code\u003e. Both these approaches are still valid. Kubernetes v1.31 added support for the \u003ccode\u003eimage\u003c/code\u003e volume type allowing Pods to declaratively pull and unpack OCI container image artifacts into a volume. This lets you package and deliver data-only artifacts such as configs, binaries, or machine learning models using standard OCI registry tools.\u003c/p\u003e\n\u003cp\u003eWith this feature, you can fully separate your data from your container image and remove the need for extra init containers or startup scripts. The image volume type has been in beta since v1.33 and is enabled by default in v1.35. Please note that using this feature requires a compatible container runtime, such as containerd v2.1 or later.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/4639\"\u003eKEP #4639\u003c/a\u003e led by SIG Node.\u003c/p\u003e\n\u003ch3\u003eEnforced kubelet credential verification for cached images\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003eimagePullPolicy: IfNotPresent\u003c/code\u003e setting currently allows a Pod to use a container image that is already cached on a node, even if the Pod itself does not possess the credentials to pull that image. A drawback of this behavior is that it creates a security vulnerability in multi-tenant clusters: if a Pod with valid credentials pulls a sensitive private image to a node, a subsequent unauthorized Pod on the same node can access that image simply by relying on the local cache.\u003c/p\u003e\n\u003cp\u003eThis KEP introduces a mechanism where the \u003ccode\u003ekubelet\u003c/code\u003e enforces credential verification for cached images. Before allowing a Pod to use a locally cached image, the \u003ccode\u003ekubelet\u003c/code\u003e checks if the Pod has the valid credentials to pull it. This ensures that only authorized workloads can use private images, regardless of whether they are already present on the node, significantly hardening the security posture for shared clusters.\u003c/p\u003e\n\u003cp\u003eIn Kubernetes v1.35, this feature has graduated to beta and is enabled by default. Users can still disable it by setting the \u003ccode\u003eKubeletEnsureSecretPulledImages\u003c/code\u003e feature gate to false. Additionally, the \u003ccode\u003eimagePullCredentialsVerificationPolicy\u003c/code\u003e flag allows operators to configure the desired security level, ranging from a mode that prioritizes backward compatibility to a strict enforcement mode that offers maximum security.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/2535\"\u003eKEP #2535\u003c/a\u003e led by SIG Node.\u003c/p\u003e\n\u003ch3\u003eFine-grained Container restart rules\u003c/h3\u003e\n\u003cp\u003eHistorically, the \u003ccode\u003erestartPolicy\u003c/code\u003e field was defined strictly at the Pod level, forcing the same behavior on all containers within a Pod. A drawback of this global setting was the lack of granularity for complex workloads, such as AI/ML training jobs. These often required \u003ccode\u003erestartPolicy: Never\u003c/code\u003e for the Pod to manage job completion, yet individual containers would benefit from in-place restarts for specific, retriable errors (like network glitches or GPU init failures).\u003c/p\u003e\n\u003cp\u003eKubernetes v1.35 addresses this by enabling \u003ccode\u003erestartPolicy\u003c/code\u003e and \u003ccode\u003erestartPolicyRules\u003c/code\u003e within the container API itself. This allows users to define restart strategies for individual regular and init containers that operate independently of the Pod's overall policy. For example, a container can now be configured to restart automatically only if it exits with a specific error code, avoiding the expensive overhead of rescheduling the entire Pod for a transient failure.\u003c/p\u003e\n\u003cp\u003eIn this release, the feature has graduated to beta and is enabled by default. Users can immediately leverage \u003ccode\u003erestartPolicyRules\u003c/code\u003e in their container specifications to optimize recovery times and resource utilization for long-running workloads, without altering the broader lifecycle logic of their Pods.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/5307\"\u003eKEP #5307\u003c/a\u003e led by SIG Node.\u003c/p\u003e\n\u003ch3\u003eCSI driver opt-in for service account tokens via secrets field\u003c/h3\u003e\n\u003cp\u003eProviding ServiceAccount tokens to Container Storage Interface (CSI) drivers has traditionally relied on injecting them into the \u003ccode\u003evolume_context\u003c/code\u003e field. This approach presents a significant security risk because \u003ccode\u003evolume_context\u003c/code\u003e is intended for non-sensitive configuration data and is frequently logged in plain text by drivers and debugging tools, potentially leaking credentials.\u003c/p\u003e\n\u003cp\u003eKubernetes v1.35 introduces an opt-in mechanism for CSI drivers to receive ServiceAccount tokens via the dedicated secrets field in the NodePublishVolume request. Drivers can now enable this behavior by setting the \u003ccode\u003eserviceAccountTokenInSecrets\u003c/code\u003e field to true in their CSIDriver object, instructing the \u003ccode\u003ekubelet\u003c/code\u003e to populate the token securely.\u003c/p\u003e\n\u003cp\u003eThe primary benefit is the prevention of accidental credential exposure in logs and error messages. This change ensures that sensitive workload identities are handled via the appropriate secure channels, aligning with best practices for secret management while maintaining backward compatibility for existing drivers.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/5538\"\u003eKEP #5538\u003c/a\u003e led by SIG Auth in cooperation with SIG Storage.\u003c/p\u003e\n\u003ch3\u003eDeployment status: count of terminating replicas\u003c/h3\u003e\n\u003cp\u003eHistorically, the Deployment status provided details on available and updated replicas but lacked explicit visibility into Pods that were in the process of shutting down. A drawback of this omission was that users and controllers could not easily distinguish between a stable Deployment and one that still had Pods executing cleanup tasks or adhering to long grace periods.\u003c/p\u003e\n\u003cp\u003eKubernetes v1.35 promotes the \u003ccode\u003eterminatingReplicas\u003c/code\u003e field within the Deployment status to beta. This field provides a count of Pods that have a deletion timestamp set but have not yet been removed from the system. This feature is a foundational step in a larger initiative to improve how Deployments handle Pod replacement, laying the groundwork for future policies regarding when to create new Pods during a rollout.\u003c/p\u003e\n\u003cp\u003eThe primary benefit is improved observability for lifecycle management tools and operators. By exposing the number of terminating Pods, external systems can now make more informed decisions such as waiting for a complete shutdown before proceeding with subsequent tasks without needing to manually query and filter individual Pod lists.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/3973\"\u003eKEP #3973\u003c/a\u003e led by SIG Apps.\u003c/p\u003e\n\u003ch2\u003eNew features in Alpha\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eThis is a selection of some of the improvements that are now alpha following the v1.35 release.\u003c/em\u003e\u003c/p\u003e\n\u003ch3\u003eGang scheduling support in Kubernetes\u003c/h3\u003e\n\u003cp\u003eScheduling interdependent workloads, such as AI/ML training jobs or HPC simulations, has traditionally been challenging because the default Kubernetes scheduler places Pods individually. This often leads to partial scheduling where some Pods start while others wait indefinitely for resources, resulting in deadlocks and wasted cluster capacity.\u003c/p\u003e\n\u003cp\u003eKubernetes v1.35 introduces native support for so-called \"gang scheduling\" via the new Workload API and PodGroup concept. This feature implements an \"all-or-nothing\" scheduling strategy, ensuring that a defined group of Pods is scheduled only if the cluster has sufficient resources to accommodate the entire group simultaneously.\u003c/p\u003e\n\u003cp\u003eThe primary benefit is improved reliability and efficiency for batch and parallel workloads. By preventing partial deployments, it eliminates resource deadlocks and ensures that expensive cluster capacity is utilized only when a complete job can run, significantly optimizing the orchestration of large-scale data processing tasks.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/4671\"\u003eKEP #4671\u003c/a\u003e led by SIG Scheduling.\u003c/p\u003e\n\u003ch3\u003eConstrained impersonation\u003c/h3\u003e\n\u003cp\u003eHistorically, the \u003ccode\u003eimpersonate\u003c/code\u003e verb in Kubernetes RBAC functioned on an all-or-nothing basis: once a user was authorized to impersonate a target identity, they gained all associated permissions. A drawback of this broad authorization was that it violated the principle of least privilege, preventing administrators from restricting impersonators to specific actions or resources.\u003c/p\u003e\n\u003cp\u003eKubernetes v1.35 introduces a new alpha feature, constrained impersonation, which adds a secondary authorization check to the impersonation flow. When enabled via the \u003ccode\u003eConstrainedImpersonation\u003c/code\u003e feature gate, the API server verifies not only the basic \u003ccode\u003eimpersonate\u003c/code\u003e permission but also checks if the impersonator is authorized for the specific action using new verb prefixes (e.g., \u003ccode\u003eimpersonate-on:\u0026#x3C;mode\u003e:\u0026#x3C;verb\u003e\u003c/code\u003e). This allows administrators to define fine-grained policies—such as permitting a support engineer to impersonate a cluster admin solely to view logs, without granting full administrative access.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/5284\"\u003eKEP #5284\u003c/a\u003e led by SIG Auth.\u003c/p\u003e\n\u003ch3\u003eFlagz for Kubernetes components\u003c/h3\u003e\n\u003cp\u003eVerifying the runtime configuration of Kubernetes components, such as the API server or \u003ccode\u003ekubelet\u003c/code\u003e, has traditionally required privileged access to the host node or process arguments. To address this, the \u003ccode\u003e/flagz\u003c/code\u003e endpoint was introduced to expose command-line options via HTTP. However, its output was initially limited to plain text, making it difficult for automated tools to parse and validate configurations reliably.\u003c/p\u003e\n\u003cp\u003eIn Kubernetes v1.35, the \u003ccode\u003e/flagz\u003c/code\u003e endpoint has been enhanced to support structured, machine-readable JSON output. Authorized users can now request a versioned JSON response using standard HTTP content negotiation, while the original plain text format remains available for human inspection. This update significantly improves observability and compliance workflows, allowing external systems to programmatically audit component configurations without fragile text parsing or direct infrastructure access.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/4828\"\u003eKEP #4828\u003c/a\u003e led by SIG Instrumentation.\u003c/p\u003e\n\u003ch3\u003eStatusz for Kubernetes components\u003c/h3\u003e\n\u003cp\u003eTroubleshooting Kubernetes components like the \u003ccode\u003ekube-apiserver\u003c/code\u003e or \u003ccode\u003ekubelet\u003c/code\u003e has traditionally involved parsing unstructured logs or text output, which is brittle and difficult to automate. While a basic \u003ccode\u003e/statusz\u003c/code\u003e endpoint existed previously, it lacked a standardized, machine-readable format, limiting its utility for external monitoring systems.\u003c/p\u003e\n\u003cp\u003eIn Kubernetes v1.35, the \u003ccode\u003e/statusz\u003c/code\u003e endpoint has been enhanced to support structured, machine-readable JSON output. Authorized users can now request this format using standard HTTP content negotiation to retrieve precise status data—such as version information and health indicators—without relying on fragile text parsing. This improvement provides a reliable, consistent interface for automated debugging and observability tools across all core components.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/4827\"\u003eKEP #4827\u003c/a\u003e led by SIG Instrumentation.\u003c/p\u003e\n\u003ch3\u003eCCM: watch-based route controller reconciliation using informers\u003c/h3\u003e\n\u003cp\u003eManaging network routes within cloud environments has traditionally relied on the Cloud Controller Manager (CCM) periodically polling the cloud provider's API to verify and update route tables. This fixed-interval reconciliation approach can be inefficient, often generating a high volume of unnecessary API calls and introducing latency between a node state change and the corresponding route update.\u003c/p\u003e\n\u003cp\u003eFor the Kubernetes v1.35 release, the cloud-controller-manager library introduces a watch-based reconciliation strategy for the route controller. Instead of relying on a timer, the controller now utilizes informers to watch for specific Node events, such as additions, deletions, or relevant field updates and triggers route synchronization only when a change actually occurs.\u003c/p\u003e\n\u003cp\u003eThe primary benefit is a significant reduction in cloud provider API usage, which lowers the risk of hitting rate limits and reduces operational overhead. Additionally, this event-driven model improves the responsiveness of the cluster's networking layer by ensuring that route tables are updated immediately following changes in cluster topology.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/5237\"\u003eKEP #5237\u003c/a\u003e led by SIG Cloud Provider.\u003c/p\u003e\n\u003ch3\u003eExtended toleration operators for threshold-based placement\u003c/h3\u003e\n\u003cp\u003eKubernetes v1.35 introduces SLA-aware scheduling by enabling workloads to express reliability requirements. The feature adds numeric comparison operators to tolerations, allowing pods to match or avoid nodes based on SLA-oriented taints such as service guarantees or fault-domain quality.\u003c/p\u003e\n\u003cp\u003eThe primary benefit is enhancing the scheduler with more precise placement. Critical workloads can demand higher-SLA nodes, while lower priority workloads can opt into lower SLA ones. This improves utilization and reduces cost without compromising reliability.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/5471\"\u003eKEP #5471\u003c/a\u003e led by SIG Scheduling.\u003c/p\u003e\n\u003ch3\u003eMutable container resources when Job is suspended\u003c/h3\u003e\n\u003cp\u003eRunning batch workloads often involves trial and error with resource limits. Currently, the Job specification is immutable, meaning that if a Job fails due to an Out of Memory (OOM) error or insufficient CPU, the user cannot simply adjust the resources; they must delete the Job and create a new one, losing the execution history and status.\u003c/p\u003e\n\u003cp\u003eKubernetes v1.35 introduces the capability to update resource requests and limits for Jobs that are in a suspended state. Enabled via the \u003ccode\u003eMutableJobPodResourcesForSuspendedJobs\u003c/code\u003e feature gate, this enhancement allows users to pause a failing Job, modify its Pod template with appropriate resource values, and then resume execution with the corrected configuration.\u003c/p\u003e\n\u003cp\u003eThe primary benefit is a smoother recovery workflow for misconfigured jobs. By allowing in-place corrections during suspension, users can resolve resource bottlenecks without disrupting the Job's lifecycle identity or losing track of its completion status, significantly improving the developer experience for batch processing.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/5440\"\u003eKEP #5440\u003c/a\u003e led by SIG Apps.\u003c/p\u003e\n\u003ch2\u003eOther notable changes\u003c/h2\u003e\n\u003ch3\u003eContinued innovation in Dynamic Resource Allocation (DRA)\u003c/h3\u003e\n\u003cp\u003eThe \u003ca href=\"https://kep.k8s.io/4381\"\u003ecore functionality\u003c/a\u003e was graduated to stable in v1.34, with the ability to turn it off. In v1.35 it is always enabled. Several alpha features have also been significantly improved and are ready for testing. We encourage users to provide feedback on these capabilities to help clear the path for their target promotion to beta in upcoming releases.\u003c/p\u003e\n\u003ch4\u003eExtended Resource Requests via DRA\u003c/h4\u003e\n\u003cp\u003eSeveral functional gaps compared to Extended Resource requests via Device Plugins were addressed, for example scoring and reuse of devices in init containers.\u003c/p\u003e\n\u003ch4\u003eDevice Taints and Tolerations\u003c/h4\u003e\n\u003cp\u003eThe new \"None\" effect can be used to report a problem without immediately affecting scheduling or running pod. DeviceTaintRule now provides status information about an ongoing eviction. The \"None\" effect can be used for a \"dry run\" before actually evicting pods:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate DeviceTaintRule with \"effect: None\".\u003c/li\u003e\n\u003cli\u003eCheck the status to see how many pods would be evicted.\u003c/li\u003e\n\u003cli\u003eReplace \"effect: None\" with \"effect: NoExecute\".\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003ePartitionable Devices\u003c/h4\u003e\n\u003cp\u003eDevices belonging to the same partitionable devices may now be defined in different ResourceSlices. You can read more in the \u003ca href=\"https://kubernetes.io/docs/concepts/scheduling-eviction/dynamic-resource-allocation/#partitionable-devices\"\u003eofficial documentation\u003c/a\u003e.\u003c/p\u003e\n\u003ch4\u003eConsumable Capacity, Device Binding Conditions\u003c/h4\u003e\n\u003cp\u003eSeveral bugs were fixed and/or more tests added. You can learn more about \u003ca href=\"https://kubernetes.io/docs/concepts/scheduling-eviction/dynamic-resource-allocation/#consumable-capacity\"\u003eConsumable Capacity\u003c/a\u003e and \u003ca href=\"https://kubernetes.io/docs/concepts/scheduling-eviction/dynamic-resource-allocation/#device-binding-conditions\"\u003eBinding Conditions\u003c/a\u003e in the official documentation.\u003c/p\u003e\n\u003ch3\u003eComparable resource version semantics\u003c/h3\u003e\n\u003cp\u003eKubernetes v1.35 changes the way that clients are allowed to interpret \u003ca href=\"https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions\"\u003eresource versions\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eBefore v1.35, the only supported comparison that clients could make was to check for string equality: if two resource versions were equal, they were the same. Clients could also provide a resource version to the API server and ask the control plane to do internal comparisons, such as streaming all events since a particular resource version.\u003c/p\u003e\n\u003cp\u003eIn v1.35, all in-tree resource versions meet a new stricter definition: the values are a special form of decimal number. And, because they can be compared, clients can do their own operations to compare two different resource versions. For example, this means that a client reconnecting after a crash can detect when it has lost updates, as distinct from the case where there has been an update but no lost changes in the meantime.\u003c/p\u003e\n\u003cp\u003eThis change in semantics enables other important use cases such as \u003ca href=\"https://kubernetes.io/docs/tasks/manage-kubernetes-objects/storage-version-migration/\"\u003estorage version migration\u003c/a\u003e, performance improvements to \u003cem\u003einformers\u003c/em\u003e (a client helper concept), and controller reliability. All of those cases require knowing whether one resource version is newer than another.\u003c/p\u003e\n\u003cp\u003eThis work was done as part of \u003ca href=\"https://kep.k8s.io/5504\"\u003eKEP #5504\u003c/a\u003e led by SIG API Machinery.\u003c/p\u003e\n\u003ch2\u003eGraduations, deprecations, and removals in v1.35\u003c/h2\u003e\n\u003ch3\u003eGraduations to stable\u003c/h3\u003e\n\u003cp\u003eThis lists all the features that graduated to stable (also known as \u003cem\u003egeneral availability\u003c/em\u003e). For a full list of updates including new features and graduations from alpha to beta, see the release notes.\u003c/p\u003e\n\u003cp\u003eThis release includes a total of 15 enhancements promoted to stable:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://kep.k8s.io/4540\"\u003eAdd CPUManager policy option to restrict reservedSystemCPUs to system daemons and interrupt processing\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://kep.k8s.io/5067\"\u003ePod Generation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://kep.k8s.io/5468\"\u003eInvariant Testing\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://kep.k8s.io/1287\"\u003eIn-Place Update of Pod Resources\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://kep.k8s.io/3619\"\u003eFine-grained SupplementalGroups control\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://kep.k8s.io/3983\"\u003eAdd support for a drop-in kubelet configuration directory\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://kep.k8s.io/5589\"\u003eRemove gogo protobuf dependency for Kubernetes API types\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://kep.k8s.io/4210\"\u003ekubelet image GC after a maximum age\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://kep.k8s.io/3673\"\u003eKubelet limit of Parallel Image Pulls\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://kep.k8s.io/4622\"\u003eAdd a TopologyManager policy option for MaxAllowableNUMANodes\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://kep.k8s.io/859\"\u003eInclude kubectl command metadata in http request headers\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://kep.k8s.io/3015\"\u003ePreferSameNode Traffic Distribution (formerly PreferLocal traffic policy / Node-level topology)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://kep.k8s.io/4368\"\u003eJob API managed-by mechanism\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://kep.k8s.io/4006\"\u003eTransition from SPDY to WebSockets\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eDeprecations, removals and community updates\u003c/h3\u003e\n\u003cp\u003eAs Kubernetes develops and matures, features may be deprecated, removed, or replaced with better ones to improve the project's overall health. See the Kubernetes \u003ca href=\"https://kubernetes.io/docs/reference/using-api/deprecation-policy/\"\u003edeprecation and removal policy\u003c/a\u003e for more details on this process. Kubernetes v1.35 includes a couple of deprecations.\u003c/p\u003e\n\u003ch4\u003eIngress NGINX retirement\u003c/h4\u003e\n\u003cp\u003eFor years, the Ingress NGINX controller has been a popular choice for routing traffic into Kubernetes clusters. It was flexible, widely adopted, and served as the standard entry point for countless applications.\u003c/p\u003e\n\u003cp\u003eHowever, maintaining the project has become unsustainable. With a severe shortage of maintainers and mounting technical debt, the community recently made the difficult decision to retire it. This isn't strictly part of the v1.35 release, but it's such an important change that we wanted to highlight it here.\u003c/p\u003e\n\u003cp\u003eConsequently, the Kubernetes project announced that Ingress NGINX will receive only best-effort maintenance until \u003cstrong\u003eMarch 2026\u003c/strong\u003e. After this date, it will be archived with no further updates. The recommended path forward is to migrate to the \u003ca href=\"https://gateway-api.sigs.k8s.io/\"\u003eGateway API\u003c/a\u003e, which offers a more modern, secure, and extensible standard for traffic management.\u003c/p\u003e\n\u003cp\u003eYou can find more in the \u003ca href=\"https://kubernetes.io/blog/2025/11/11/ingress-nginx-retirement/\"\u003eofficial blog post\u003c/a\u003e.\u003c/p\u003e\n\u003ch4\u003eRemoval of cgroup v1 support\u003c/h4\u003e\n\u003cp\u003eWhen it comes to managing resources on Linux nodes, Kubernetes has historically relied on cgroups (control groups). While the original cgroup v1 was functional, it was often inconsistent and limited. That is why Kubernetes introduced support for cgroup v2 back in v1.25, offering a much cleaner, unified hierarchy and better resource isolation.\u003c/p\u003e\n\u003cp\u003eBecause cgroup v2 is now the modern standard, Kubernetes is ready to retire the legacy cgroup v1 support in v1.35. This is an important notice for cluster administrators: if you are still running nodes on older Linux distributions that don't support cgroup v2, your \u003ccode\u003ekubelet\u003c/code\u003e will fail to start. To avoid downtime, you will need to migrate those nodes to systems where cgroup v2 is enabled.\u003c/p\u003e\n\u003cp\u003eTo learn more, read \u003ca href=\"https://kubernetes.io/docs/concepts/architecture/cgroups/\"\u003eabout cgroup v2\u003c/a\u003e;\u003cbr\u003e\nyou can also track the switchover work via \u003ca href=\"https://kep.k8s.io/5573\"\u003eKEP-5573: Remove cgroup v1 support\u003c/a\u003e.\u003c/p\u003e\n\u003ch4\u003eDeprecation of ipvs mode in kube-proxy\u003c/h4\u003e\n\u003cp\u003eYears ago, Kubernetes adopted the \u003ca href=\"https://kubernetes.io/docs/reference/networking/virtual-ips/#proxy-mode-ipvs\"\u003e\u003ccode\u003eipvs\u003c/code\u003e\u003c/a\u003e mode in \u003ccode\u003ekube-proxy\u003c/code\u003e to provide faster load balancing than the standard \u003ca href=\"https://kubernetes.io/docs/reference/networking/virtual-ips/#proxy-mode-iptables\"\u003e\u003ccode\u003eiptables\u003c/code\u003e\u003c/a\u003e. While it offered a performance boost, keeping it in sync with evolving networking requirements created too much technical debt and complexity.\u003c/p\u003e\n\u003cp\u003eBecause of this maintenance burden, Kubernetes v1.35 deprecates \u003ccode\u003eipvs\u003c/code\u003e mode. Although the mode remains available in this release, \u003ccode\u003ekube-proxy\u003c/code\u003e will now emit a warning on startup when configured to use it. The goal is to streamline the codebase and focus on modern standards. For Linux nodes, you should begin transitioning to \u003ca href=\"https://kubernetes.io/docs/reference/networking/virtual-ips/#proxy-mode-nftables\"\u003e\u003ccode\u003enftables\u003c/code\u003e\u003c/a\u003e, which is now the recommended replacement.\u003c/p\u003e\n\u003cp\u003eYou can find more in \u003ca href=\"https://kep.k8s.io/5495\"\u003eKEP-5495: Deprecate ipvs mode in kube-proxy\u003c/a\u003e.\u003c/p\u003e\n\u003ch4\u003eFinal call for containerd v1.X\u003c/h4\u003e\n\u003cp\u003eWhile Kubernetes v1.35 still supports containerd 1.7 and other LTS releases, this is the final version with such support. The SIG Node community has designated v1.35 as the last release to support the containerd v1.X series.\u003c/p\u003e\n\u003cp\u003eThis serves as an important reminder: before upgrading to the next Kubernetes version, you must switch to containerd 2.0 or later. To help identify which nodes need attention, you can monitor the \u003ccode\u003ekubelet_cri_losing_support\u003c/code\u003e metric within your cluster.\u003c/p\u003e\n\u003cp\u003eYou can find more in the \u003ca href=\"https://kubernetes.io/blog/2025/09/12/kubernetes-v1-34-cri-cgroup-driver-lookup-now-ga/#announcement-kubernetes-is-deprecating-containerd-v1-y-support\"\u003eofficial blog post\u003c/a\u003e or in \u003ca href=\"https://kep.k8s.io/4033\"\u003eKEP-4033: Discover cgroup driver from CRI\u003c/a\u003e.\u003c/p\u003e\n\u003ch4\u003eImproved Pod stability during kubelet restarts\u003c/h4\u003e\n\u003cp\u003ePreviously, restarting the \u003ccode\u003ekubelet\u003c/code\u003e service often caused a temporary disruption in Pod status. During a restart, the kubelet would reset container states, causing healthy Pods to be marked as \u003ccode\u003eNotReady\u003c/code\u003e and removed from load balancers, even if the application itself was still running correctly.\u003c/p\u003e\n\u003cp\u003eTo address this reliability issue, this behavior has been corrected to ensure seamless node maintenance. The \u003ccode\u003ekubelet\u003c/code\u003e now properly restores the state of existing containers from the runtime upon startup. This ensures that your workloads remain \u003ccode\u003eReady\u003c/code\u003e and traffic continues to flow uninterrupted during \u003ccode\u003ekubelet\u003c/code\u003e restarts or upgrades.\u003c/p\u003e\n\u003cp\u003eYou can find more in \u003ca href=\"https://kep.k8s.io/4871\"\u003eKEP-4781: Fix inconsistent container ready state after kubelet restart\u003c/a\u003e.\u003c/p\u003e\n\u003ch2\u003eRelease notes\u003c/h2\u003e\n\u003cp\u003eCheck out the full details of the Kubernetes v1.35 release in our \u003ca href=\"https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.35.md\"\u003erelease notes\u003c/a\u003e.\u003c/p\u003e\n\u003ch2\u003eAvailability\u003c/h2\u003e\n\u003cp\u003eKubernetes v1.35 is available for download on or on the \u003ca href=\"https://kubernetes.io/releases/download/\"\u003eKubernetes download page\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eTo get started with Kubernetes, check out these \u003ca href=\"https://kubernetes.io/docs/tutorials/\"\u003einteractive tutorials\u003c/a\u003e or run local Kubernetes clusters using \u003ca href=\"https://minikube.sigs.k8s.io/\"\u003eminikube\u003c/a\u003e. You can also easily install v1.35 using \u003ca href=\"https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/\"\u003ekubeadm\u003c/a\u003e.\u003c/p\u003e\n\u003ch2\u003eRelease team\u003c/h2\u003e\n\u003cp\u003eKubernetes is only possible with the support, commitment, and hard work of its community. Each release team is made up of dedicated community volunteers who work together to build the many pieces that make up the Kubernetes releases you rely on. This requires the specialized skills of people from all corners of our community, from the code itself to its documentation and project management.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/cncf/memorials/blob/main/han-kang.md\"\u003eWe honor the memory of Han Kang\u003c/a\u003e, a long-time contributor and respected engineer whose technical excellence and infectious enthusiasm left a lasting impact on the Kubernetes community. Han was a significant force within SIG Instrumentation and SIG API Machinery, earning a \u003ca href=\"https://www.kubernetes.dev/community/awards/2021/\"\u003e2021 Kubernetes Contributor Award\u003c/a\u003e for his critical work and sustained commitment to the project's core stability. Beyond his technical contributions, Han was deeply admired for his generosity as a mentor and his passion for building connections among people. He was known for \"opening doors\" for others, whether guiding new contributors through their first pull requests or supporting colleagues with patience and kindness. Han’s legacy lives on through the engineers he inspired, the robust systems he helped build, and the warm, collaborative spirit he fostered within the cloud native ecosystem.\u003c/p\u003e\n\u003cp\u003eWe would like to thank the entire \u003ca href=\"https://github.com/kubernetes/sig-release/blob/master/releases/release-1.35/release-team.md\"\u003eRelease Team\u003c/a\u003e for the hours spent hard at work to deliver the Kubernetes v1.35 release to our community. The Release Team's membership ranges from first-time shadows to returning team leads with experience forged over several release cycles. We are incredibly grateful to our Release Lead, \u003ca href=\"https://github.com/drewhagen\"\u003eDrew Hagen\u003c/a\u003e, whose hands-on guidance and vibrant energy not only navigated us through complex challenges but also fueled the community spirit behind this successful release.\u003c/p\u003e\n\u003ch2\u003eProject velocity\u003c/h2\u003e\n\u003cp\u003eThe CNCF K8s \u003ca href=\"https://k8s.devstats.cncf.io/d/11/companies-contributing-in-repository-groups?orgId=1\u0026#x26;var-period=m\u0026#x26;var-repogroup_name=All\"\u003eDevStats\u003c/a\u003e project aggregates a number of interesting data points related to the velocity of Kubernetes and various sub-projects. This includes everything from individual contributions to the number of companies that are contributing and is an illustration of the depth and breadth of effort that goes into evolving this ecosystem.\u003c/p\u003e\n\u003cp\u003eDuring the v1.35 release cycle, which spanned 14 weeks from 15th September 2025 to 17th December 2025, Kubernetes received contributions from as many as 85 different companies and 419 individuals. In the wider cloud native ecosystem, the figure goes up to 281 companies, counting 1769 total contributors.\u003c/p\u003e\n\u003cp\u003eNote that \"contribution\" counts when someone makes a commit, code review, comment, creates an issue or PR, reviews a PR (including blogs and documentation) or comments on issues and PRs.\u003cbr\u003e\nIf you are interested in contributing, visit \u003ca href=\"https://www.kubernetes.dev/docs/guide/#getting-started\"\u003eGetting Started\u003c/a\u003e on our contributor website.\u003c/p\u003e\n\u003cp\u003eSources for this data:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://k8s.devstats.cncf.io/d/11/companies-contributing-in-repository-groups?orgId=1\u0026#x26;from=1757890800000\u0026#x26;to=1765929599000\u0026#x26;var-period=d28\u0026#x26;var-repogroup_name=Kubernetes\u0026#x26;var-repo_name=kubernetes%2Fkubernetes\"\u003eCompanies contributing to Kubernetes\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://k8s.devstats.cncf.io/d/11/companies-contributing-in-repository-groups?orgId=1\u0026#x26;from=1757890800000\u0026#x26;to=1765929599000\u0026#x26;var-period=d28\u0026#x26;var-repogroup_name=All\u0026#x26;var-repo_name=kubernetes%2Fkubernetes\"\u003eOverall ecosystem contributions\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eEvents update\u003c/h2\u003e\n\u003cp\u003eExplore upcoming Kubernetes and cloud native events, including KubeCon + CloudNativeCon, KCD, and other notable conferences worldwide. Stay informed and get involved with the Kubernetes community!\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFebruary 2026\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.kcddelhi.com/\"\u003e\u003cstrong\u003eKCD - Kubernetes Community Days: New Delhi\u003c/strong\u003e\u003c/a\u003e: Feb 21, 2026 | New Delhi, India\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://community.cncf.io/events/details/cncf-kcd-guadalajara-presents-kcd-guadalajara-open-source-contributor-summit/cohost-kcd-guadalajara\"\u003e\u003cstrong\u003eKCD - Kubernetes Community Days: Guadalajara\u003c/strong\u003e\u003c/a\u003e: Feb 23, 2026 | Guadalajara, Mexico\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eMarch 2026\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://events.linuxfoundation.org/kubecon-cloudnativecon-europe/\"\u003e\u003cstrong\u003eKubeCon + CloudNativeCon Europe 2026\u003c/strong\u003e\u003c/a\u003e: Mar 23-26, 2026 | Amsterdam, Netherlands\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eMay 2026\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://community.cncf.io/events/details/cncf-kcd-toronto-presents-kcd-toronto-canada-2026/\"\u003e\u003cstrong\u003eKCD - Kubernetes Community Days: Toronto\u003c/strong\u003e\u003c/a\u003e: May 13, 2026 | Toronto, Canada\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://cloudnativefinland.org/kcd-helsinki-2026/\"\u003e\u003cstrong\u003eKCD - Kubernetes Community Days: Helsinki\u003c/strong\u003e\u003c/a\u003e: May 20, 2026 | Helsinki, Finland\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eJune 2026\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://events.linuxfoundation.org/kubecon-cloudnativecon-china/\"\u003e\u003cstrong\u003eKubeCon + CloudNativeCon China 2026\u003c/strong\u003e\u003c/a\u003e: Jun 10-11, 2026 | Hong Kong\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://events.linuxfoundation.org/kubecon-cloudnativecon-india/\"\u003e\u003cstrong\u003eKubeCon + CloudNativeCon India 2026\u003c/strong\u003e\u003c/a\u003e: Jun 18-19, 2026 | Mumbai, India\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://community.cncf.io/kcd-kuala-lumpur-2026/\"\u003e\u003cstrong\u003eKCD - Kubernetes Community Days: Kuala Lumpur\u003c/strong\u003e\u003c/a\u003e: Jun 27, 2026 | Kuala Lumpur, Malaysia\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eJuly 2026\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://events.linuxfoundation.org/kubecon-cloudnativecon-japan/\"\u003e\u003cstrong\u003eKubeCon + CloudNativeCon Japan 2026\u003c/strong\u003e\u003c/a\u003e: Jul 29-30, 2026 | Yokohama, Japan\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eYou can find the latest event details \u003ca href=\"https://community.cncf.io/events/#/list\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\u003ch2\u003eUpcoming release webinar\u003c/h2\u003e\n\u003cp\u003eJoin members of the Kubernetes v1.35 Release Team on \u003cstrong\u003eWednesday, January 14, 2026, at 5:00 PM (UTC)\u003c/strong\u003e to learn about the release highlights of this release. For more information and registration, visit the \u003ca href=\"https://community.cncf.io/events/details/cncf-cncf-online-programs-presents-cloud-native-live-kubernetes-v135-release/\"\u003eevent page\u003c/a\u003e on the CNCF Online Programs site.\u003c/p\u003e\n\u003ch2\u003eGet involved\u003c/h2\u003e\n\u003cp\u003eThe simplest way to get involved with Kubernetes is by joining one of the many \u003ca href=\"https://github.com/kubernetes/community/blob/master/sig-list.md\"\u003eSpecial Interest Groups\u003c/a\u003e (SIGs) that align with your interests. Have something you’d like to broadcast to the Kubernetes community? Share your voice at our weekly \u003ca href=\"https://github.com/kubernetes/community/tree/master/communication\"\u003ecommunity meeting\u003c/a\u003e, and through the channels below. Thank you for your continued feedback and support.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFollow us on Bluesky \u003ca href=\"https://bsky.app/profile/kubernetes.io\"\u003e@Kubernetesio\u003c/a\u003e for the latest updates\u003c/li\u003e\n\u003cli\u003eJoin the community discussion on \u003ca href=\"https://discuss.kubernetes.io/\"\u003eDiscuss\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eJoin the community on \u003ca href=\"http://slack.k8s.io/\"\u003eSlack\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ePost questions (or answer questions) on \u003ca href=\"http://stackoverflow.com/questions/tagged/kubernetes\"\u003eStack Overflow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eShare your Kubernetes \u003ca href=\"https://docs.google.com/a/linuxfoundation.org/forms/d/e/1FAIpQLScuI7Ye3VQHQTwBASrgkjQDSS5TP0g3AXfFhwSM9YpHgxRKFA/viewform\"\u003estory\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eRead more about what’s happening with Kubernetes on the \u003ca href=\"https://kubernetes.io/blog/\"\u003eblog\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eLearn more about the \u003ca href=\"https://github.com/kubernetes/sig-release/tree/master/release-team\"\u003eKubernetes Release Team\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n","pageTitle":"Kubernetes v1.35: Timbernetes (The World Tree Release) - by Graziano Casto","pageDescription":"Kubernetes v1.35: Timbernetes (The World Tree Release) - by Graziano Casto","pageLink":"https://castograziano.com/articles/kubernetes-v135-announcement","pageImage":"https://castograziano.com/casto_graziano_personal_website.png"},"schema":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kubernetes v1.35: Timbernetes (The World Tree Release)","datePublished":"2025-12-17T00:00:00.000Z","dateModified":"2025-12-17T00:00:00.000Z","author":[{"@type":"Person","name":"Graziano Casto","url":"https://castograziano.com/about-me"}]}},"__N_SSG":true},"page":"/articles/[slug]","query":{"slug":"kubernetes-v135-announcement"},"buildId":"L5vrGkgVuQJWNjQ2eNbXG","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>