{"pageProps":{"data":{"article":{"title":"Cognitive Architecture: How LLMs Are Reshaping Software Architecture","date":"2025-06-11"},"children":"<p><a href=\"https://dzone.com/articles/cognitive-architecture-llms-changing-software-development\">Published by DZONE</a></p>\n<p>Software architecture has long been rooted in object-oriented and, later, service-oriented paradigms. These models have helped teams build modular systems, isolating behavior into manageable services that communicate over well-defined APIs. As systems grew, microservices brought benefits like scalability and decoupling, but also introduced significant complexity in orchestration.</p>\n<p>Today, we're witnessing a fundamental shift. The growing influence of foundation models, particularly large language models (LLMs), is changing how we approach software design. These models aren't just code libraries; they can understand context, reason about goals, and generate human-like responses. This has led to the rise of agent-oriented programming, where autonomous agents, not statically programmed services, drive system behavior. In this new paradigm, agents are constructed from language models, structured prompts, memory layers, and external tools.</p>\n<p>What drives them is the <strong>cognitive loop</strong>: a cycle where an agent processes input, reasons over its state, takes actions using tools, and updates its memory. As small language models (SLMs) become more capable, this model is evolving to balance performance with flexibility and cost-efficiency.</p>\n<h3>The cognitive architecture</h3>\n<p>At the core of a cognitive architecture is a language model, effectively the brain of the system. This model is responsible for interpreting input, reasoning about goals, and planning actions. But reasoning alone is not enough. Just like the human brain depends on sensory organs and muscles to perceive and act on the world, an intelligent agent must be able to access and manipulate external systems in a structured way. This is the essence of agentic AI: giving models the ability to act, not just think.</p>\n<p>One emerging approach to enable this interaction is the <a href=\"https://www.anthropic.com/news/model-context-protocol\">Model Context Protocol (MCP)</a>, an open standard developed by Anthropic. MCP aims to provide a standardized interface through which models can retrieve contextual information and invoke tools in their environment. However, it’s important to note that MCP is still an early attempt, promising but not yet an established standard. It represents a broader effort across the AI community to define patterns and protocols that allow agents to interface safely and reliably with external components such as APIs, databases, and services.</p>\n<p>In systems that use MCP or similar abstractions, the architecture separates reasoning from execution: the model focuses on understanding, planning, and decision-making, while dedicated tooling (like an MCP server) handles the actual execution of external operations. This creates a cognitive loop: the model observes inputs (from the user, sensors, or past interactions), interprets them using memory and reasoning, then takes action through tools that generate new inputs and continue the cycle.</p>\n<p>The choice of model driving this architecture is essential. Large language models (LLMs) and small language models (SLMs) offer distinct trade-offs depending on the complexity of the task, the resource constraints, and the required level of reasoning. LLMs such as GPT-4, Claude, and Gemini are trained on massive corpora and exhibit broad generalization, abstraction, and conversational capabilities. They can manage multi-turn dialogues, resolve ambiguity, and reason across diverse domains.</p>\n<p>However, they come at a high computational cost and typically require substantial infrastructure to operate efficiently. On the other hand, SLMs like DistilBERT, TinyLLaMA, and Phi-2 are optimized for speed and efficiency. They are lightweight, often open-source, and can be deployed on edge devices or environments with limited resources. While their reasoning capabilities are more narrow and their context windows smaller, they are highly effective for specialized, domain-specific tasks where determinism and performance are prioritized over generalization. This naturally leads to hybrid system designs, where LLMs are responsible for global coordination and strategy, while SLMs handle routine or narrowly scoped operations.</p>\n<p>Below is a comparison highlighting the core differences between the two:</p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Large Language Models (LLMs)</th>\n<th>Small Language Models (SLMs)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Examples</strong></td>\n<td>GPT-4, Claude, Gemini</td>\n<td>DistilBERT, TinyLLaMA, Phi-2</td>\n</tr>\n<tr>\n<td><strong>Model Size</strong></td>\n<td>Billions to trillions of parameters</td>\n<td>Tens to hundreds of millions of parameters</td>\n</tr>\n<tr>\n<td><strong>Reasoning Ability</strong></td>\n<td>High, can handle abstract, multi-step tasks</td>\n<td>Limited to focused, well-defined tasks</td>\n</tr>\n<tr>\n<td><strong>Context Window</strong></td>\n<td>Large (32k–128k tokens)</td>\n<td>Small to medium (512–8k tokens)</td>\n</tr>\n<tr>\n<td><strong>Inference Cost</strong></td>\n<td>High</td>\n<td>Low</td>\n</tr>\n<tr>\n<td><strong>Deployment</strong></td>\n<td>Cloud, high-performance infrastructure</td>\n<td>Edge, browser, lightweight servers</td>\n</tr>\n<tr>\n<td><strong>Use cases</strong></td>\n<td>Complex workflows, multi-agent coordination</td>\n<td>Classification, log parsing, quick lookups</td>\n</tr>\n</tbody>\n</table>\n<p>Most cognitive systems benefit from hybrid designs, where an LLM oversees high-level reasoning and coordination, while SLMs handle specialized, well-scoped operations combining performance, adaptability, and cost-efficiency.</p>\n<h3>From multi-service to multi-agent architectures: patterns for making agents work together</h3>\n<p>As cognitive architectures mature, they evolve from handling isolated use cases to coordinating distributed tasks across multiple agents. This mirrors the shift from monolithic applications to microservice-based designs — only here, the components are intelligent agents that understand goals, reason about actions, and collaborate toward shared outcomes.</p>\n<p>In multi-agent architectures, each agent can be powered by the same or different language models, and they may have overlapping or distinct toolsets. Often, agents are also assigned specific personas or domains of expertise, allowing them to handle different parts of a broader workflow. The structure of multi-agent systems generally falls along a spectrum between two extremes: <strong>vertical</strong> and <strong>horizontal</strong> coordination.</p>\n<p>In vertical architectures, one agent plays the role of leader, orchestrating others and delegating responsibilities in a top-down manner. Communication typically flows through this central agent, though in some cases, all agents may share a joint conversational thread overseen by the leader. These systems work well for hierarchical workflows that benefit from clear task separation and control. In contrast, horizontal architectures treat all agents as peers. Each agent can see the shared context and respond accordingly, contributing ideas, solving tasks, or calling tools independently. These systems are better suited for collaborative environments where feedback, shared reasoning, and open discussion improve task outcomes.</p>\n<p>Whether organized hierarchically or as peers, these agents can exchange information through memory structures, direct messaging, or via orchestration protocols such as <a href=\"https://github.com/google-a2a/A2A\">A2A (Agent-to-Agent)</a>. As a result, systems gain modularity and resilience: agents can be updated or swapped without affecting the overall design, and capabilities can grow organically by expanding the agent set.</p>\n<h3>Agent-Oriented systems: an interactive shopping assistant example</h3>\n<p>To illustrate the capabilities of cognitive architectures, let’s consider an <strong>interactive shopping assistant</strong> for an e-commerce platform. Unlike a traditional product recommendation system focused on speed and structured queries, this assistant prioritizes a flexible, conversational user experience, allowing users to describe their preferences naturally and refine their choices through dialogue.</p>\n<p>Imagine a user looking for a new outfit who might start with a free-form request like: “I’m looking for a red floral summer dress in medium size.” Instead of routing this through predefined APIs and checkboxes, we create an agent powered by an LLM that can understand such nuanced requests, extract product attributes, query the catalog, filter results, and engage in a dynamic conversation to refine the search.</p>\n<p>Here’s how this could work with an agent-oriented approach, leveraging frameworks like <a href=\"https://google.github.io/adk-docs/\">Google's Agent Development Kit (ADK)</a>, LangChain, or AutoGen. Let's assume we use ADK and have several tools available to the agent:</p>\n<ul>\n<li><code>product_search(query_parameters: dict)</code>: This tool interacts with the product catalog. Instead of fetching the entire catalog, it takes structured parameters (e.g., <code>{'color': 'red', 'pattern': 'floral', 'category': 'dress', 'size': 'medium'}</code>) and returns a filtered list of products. This addresses the context window limitation by allowing the agent to perform targeted searches.</li>\n<li><code>image_recognition(image_url: str)</code>: This tool processes an uploaded image to identify attributes like color, style, and patterns.</li>\n<li><code>refine_search(product_id: str, new_parameters: dict)</code>: Allows the agent to modify an existing search or product selection based on user feedback.</li>\n<li><code>user_profile_update(preferences: dict)</code>: Stores user preferences in a vector memory or database for personalized recommendations in future interactions.</li>\n</ul>\n<p>The agent’s workflow would incorporate a <strong>planning phase</strong> and the ability to handle <strong>multi-turn interactions</strong>:</p>\n<ol>\n<li><strong>Initial request and intent understanding (LLM)</strong>: The user says, “I’m looking for a red floral summer dress in medium size.” The LLM agent, acting as the brain, processes this free-form text. It identifies the user’s intent (find a dress) and extracts key attributes: <code>color: red, pattern: floral, category: dress, size: medium</code>.\n<ul>\n<li><strong>Planning</strong>: The agent determines the best course of action. It decides to use the product_search tool first.</li>\n</ul>\n</li>\n<li><strong>Tool invocation and execution</strong>: The agent constructs a structured query based on the extracted attributes and calls the product_search tool: <code>product_search({'color': 'red', 'pattern': 'floral', 'category': 'dress', 'size': 'medium'})</code>.</li>\n<li><strong>Tool output and response generation (LLM)</strong>: The <code>product_search</code> tool returns a list of matching dresses. The LLM then synthesizes these results into a human-readable response, perhaps showing a few top recommendations with product names and prices. For example: \"I found a few red floral summer dresses for you! How about the 'Crimson Bloom Maxi Dress' or the 'Garden Party Midi Dress'?\"</li>\n<li><strong>Refinement and dialogue (LLM and tools)</strong>: The user responds, “I like the Garden Party Midi Dress, but do you have it in blue instead of red?”\n<ul>\n<li><strong>Reasoning and planning</strong>: The LLM understands this is a refinement request. It recognizes the <code>product_id</code> (Garden Party Midi Dress) and the new <code>color: blue</code>. It plans to use the <code>refine_search</code> tool.</li>\n<li><strong>Tool invocation</strong>: The agent calls <code>refine_search({'product_id': 'Garden Party Midi Dress', 'color': 'blue'})</code>.</li>\n<li><strong>Guardrails/validation</strong>: If the <code>refine_search</code> tool returns no results, the agent is programmed with a fallback: \"Unfortunately, the 'Garden Party Midi Dress' isn't available in blue. Would you like to see other blue floral dresses?\" This demonstrates a guardrail to ensure a graceful fallback rather than a generic error.</li>\n</ul>\n</li>\n<li><strong>Image-based search (optional)</strong>: If the user uploads a picture and says, “Find me something like this,” the agent could leverage the <code>image_recognition</code> tool to extract visual attributes, then use <code>product_search</code> with those attributes.</li>\n</ol>\n<p>Here’s a simplified Python example demonstrating the ADK agent with multiple tools:</p>\n<pre><code class=\"language-python\">import os\nimport requests\nfrom google.adk.agents import Agent\n\ndef product_search(query_parameters: dict) -> dict:\n    \"\"\"\n    Searches the product catalog based on structured query parameters.\n\n    Args:\n        query_parameters (dict): A dictionary of parameters like {'color': 'red', 'category': 'dress'}.\n\n    Returns:\n        dict: The search response or an error message.\n    \"\"\"\n    try:\n        products_api_url = os.getenv(\"PRODUCTS_SEARCH_API_PATH\")\n        if not products_api_url:\n            raise ValueError(\"PRODUCTS_SEARCH_API_PATH not defined.\")\n        \n        response = requests.get(products_api_url, params=query_parameters)\n        response.raise_for_status()\n        return {\"status\": \"success\", \"report\": {\"data\": response.json()}}\n    except Exception as e:\n        return {\"status\": \"error\", \"error_message\": f\"Error searching products: {str(e)}\"}\n\ndef refine_search(product_id: str, new_parameters: dict) -> dict:\n    \"\"\"\n    Refines an existing product search or modifies parameters for a specific product.\n    \n    Args:\n        product_id (str): The ID of the product to refine.\n        new_parameters (dict): New parameters to apply (e.g., {'color': 'blue'}).\n\n    Returns:\n        dict: The updated product information or an error.\n    \"\"\"\n    # This would typically interact with a product details API or an update mechanism\n    print(f\"Refining product {product_id} with parameters: {new_parameters}\")\n    # Simulate a successful refinement for demonstration\n    return {\"status\": \"success\", \"report\": {\"message\": f\"Refined search for {product_id} with new parameters.\"}}\n\n\nroot_agent = Agent(\n    name=\"interactive_shopping_assistant\",\n    model=\"gemini-2.0-flash\", # Or a more capable LLM like Gemini 1.5 Pro for complex reasoning\n    description=(\n        \"An agent that provides a conversational interface for product discovery and recommendations.\"\n    ),\n    instruction=(\n        \"You are a helpful interactive shopping assistant. Understand user preferences from freeform text or images, \"\n        \"use available tools to find products, and engage in multi-turn dialogues to refine results. \"\n        \"If a search yields no results, suggest alternative options gracefully.\"\n    ),\n    tools=[product_search, refine_search], # Add other tools like image_recognition as needed\n)\n\n# Example of agent processing a request (conceptual)\n# user_input_1 = \"I'm looking for a red floral summer dress in medium size.\"\n# agent_response_1 = root_agent.process_input(user_input_1) \n# print(agent_response_1)\n# \n# user_input_2 = \"I like the Garden Party Midi Dress, but do you have it in blue instead of red?\"\n# agent_response_2 = root_agent.process_input(user_input_2)\n# print(agent_response_2)\n</code></pre>\n<p>The agentic approach simplifies orchestration logic by allowing the LLM to interpret intent, sequence tool usage, and manage context within a single reasoning loop. This makes the architecture highly adaptive to shifting user expectations and business needs, especially when new product attributes or complex search patterns emerge.</p>\n<p>The ability to integrate user feedback in real-time, refine searches conversationally, and handle diverse input modalities (like text or images) demonstrates why cognitive architectures excel in scenarios requiring flexibility and natural interaction.</p>\n<h3>Benefits and challenges of cognitive architectures</h3>\n<p>One of the most significant advantages of cognitive architectures is the <strong>natural interface</strong> they provide. Users and developers can interact with systems through plain language rather than structured APIs or formal input schemas. This allows faster iteration and reduces the complexity typically associated with tightly coupled service orchestration. But the real shift comes from the agent’s ability to <strong>reason</strong>.</p>\n<p>Reasoning is a core part of human intelligence: it allows us to make informed decisions, adapt to unexpected situations, and learn from new information. The same capabilities are essential for agents. Without reasoning, an agent might take user input too literally, fail to account for multi-step implications, or ignore relevant context. With reasoning, agents can plan, reflect, revise, and make decisions autonomously.</p>\n<p>In practice, most agent architectures include a dedicated <strong>planning phase</strong>, where the model chooses how to act before executing any specific steps. This planning can follow various strategies, such as task decomposition, multi-option evaluation, retrieval-augmented guidance, or plan refinement. More advanced techniques, like representing plans as graphs (e.g., in Plan Like a Graph or PLaG), allow agents to execute steps in parallel, improving performance for workflows with many independent subtasks. The ability to <strong>adapt</strong> is another key benefit. Agents don’t require redeployment to change behavior: often, changing a prompt or swapping a tool is enough. They can integrate feedback, adjust strategies in real time, and operate in environments where the full task definition is not known upfront.</p>\n<p>Of course, there are tradeoffs. Agents must manage <strong>limited context windows</strong>, which can impact long-running or multi-step tasks. Reasoning itself requires larger models, which increases the cost. Using SLMs can reduce this overhead, but it comes with limited planning and abstraction capabilities. There’s also the challenge of <strong>unpredictability</strong>. Traditional systems are deterministic and easy to debug. In contrast, agents reason probabilistically, and tracing their decisions isn’t straightforward. Ensuring consistent outputs often means combining language model-based reasoning with <strong>guardrails, fallback logic, or rules-based validators</strong>, as seen in our shopping assistant example, where the agent gracefully handles unavailable product variations.</p>\n<p>Finally, <strong>observability</strong> remains a critical frontier. As reasoning becomes a central part of system behavior, we need better tools to trace decisions, evaluate alternatives, and debug unexpected outputs. This will be key to deploying robust, production-grade agentic systems at scale.</p>\n<h3>Conclusion</h3>\n<p>The movement toward agentic architectures signals a deeper change in how we think about software. Instead of writing detailed instructions and managing services manually, we are increasingly enabling intelligent agents to reason, act, and learn on our behalf. By carefully combining LLMs and SLMs, developers can design systems that are not only more powerful but also more adaptable. The cognitive capabilities of modern models allow us to abstract complexity and work closer to natural human thinking.</p>\n<p>Yet this power comes with new responsibilities. As we step into a world of cognitive software, we must rethink reliability, cost management, and transparency. The future of software may not be written in code alone: it may be prompted, reasoned, and evolved through agents that think alongside us.</p>\n","pageTitle":"Cognitive Architecture: How LLMs Are Reshaping Software Architecture - by Graziano Casto","pageDescription":"Cognitive Architecture: How LLMs Are Reshaping Software Architecture - by Graziano Casto","pageLink":"https://castograziano.com/articles/cognitive-architecture-how-llms-are-reshaping-software-architecture","pageImage":"https://castograziano.com/casto_graziano_personal_website.png"},"schema":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Cognitive Architecture: How LLMs Are Reshaping Software Architecture","datePublished":"2025-06-11T00:00:00.000Z","dateModified":"2025-06-11T00:00:00.000Z","author":[{"@type":"Person","name":"Graziano Casto","url":"https://castograziano.com/about-me"}]}},"__N_SSG":true}