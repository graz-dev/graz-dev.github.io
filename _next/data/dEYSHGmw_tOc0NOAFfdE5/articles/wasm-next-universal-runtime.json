{"pageProps":{"data":{"article":{"title":"WebAssembly: from browser plugin to the next universal runtime","date":"2025-08-04"},"children":"<p><a href=\"https://dzone.com/articles/webassembly-from-browser-plugin-to-the-next-univer\">Published by DZONE co-authored with Alex Casalboni (Developer Advocate @ Edgee)</a></p>\n<p>For decades, the digital world has converged on a single, universal computing platform: the web browser. This remarkable piece of software, present on nearly every device, promised a \"write once, run anywhere\" paradigm, but with a crucial limitation, it only spoke one language natively: JavaScript. While incredibly versatile, JavaScript's nature as a dynamically typed, interpreted language created a performance ceiling. For computationally intensive tasks, developers often hit a wall, unable to achieve the raw speed of native applications. This limitation also meant that the vast, mature ecosystems of code written in languages like C++, C, and Rust were largely inaccessible on the web without cumbersome and often inefficient cross-compilation to JavaScript.</p>\n<p>Into this landscape emerged <a href=\"https://dzone.com/articles/what-is-webassembly\"><strong>WebAssembly</strong></a> <strong>(Wasm)</strong>. Often referred to as a fourth standard language for the web alongside HTML, CSS, and JavaScript, Wasm was not designed to replace JavaScript but to be its powerful companion. It is a binary instruction format, a low-level, assembly-like language that <strong>serves as a portable compilation target</strong>. This simple yet profound idea meant that developers could take existing code written in high-performance languages, compile it into a compact Wasm binary, and run it directly within the browser at near-native speeds. This breakthrough unlocked a new class of applications that were previously impractical for the web, from sophisticated in-browser tools to full-fledged 3D gaming engines.</p>\n<p>The design of WebAssembly was forged in the demanding and often hostile environment of the public internet, leading to a set of foundational principles that would define its destiny. It had to be <strong>fast</strong>, with a compact binary format that could be decoded and executed far more efficiently than parsing text-based JavaScript. It had to be <strong>secure</strong>, running inside a tightly controlled, memory-safe sandbox that isolated it from the host system and other browser tabs. And it had to be <strong>portable</strong>, a universal format independent of any specific operating system or hardware architecture.</p>\n<p>These very principles, essential for its success in the browser, were also the seeds of a much grander vision. This article charts the remarkable journey of WebAssembly, following its evolution from a browser-based performance booster into a foundational technology that is reshaping our approach to cloud, edge, and distributed computing, promising a future built on a truly universal runtime.</p>\n<h3>Beyond the Browser With the WebAssembly System Interface (WASI)</h3>\n<p>WebAssembly's potential was too significant to remain confined within the browser. Developers and architects quickly recognized that a portable, fast, and secure runtime could be immensely valuable for server-side applications. However, a critical piece of the puzzle was missing.</p>\n<p>Wasm modules running in the browser can interact with its environment through a rich set of Web APIs, allowing it to fetch data, manipulate the screen, or play audio. Server-side applications have a <strong>completely different set of needs</strong>: they must read and write files, access environment variables, open network sockets, and interact with the system clock. Without a standardized way to perform these basic operations, server-side Wasm would be a collection of incompatible, proprietary solutions, shattering its promise of portability.</p>\n<p>The solution is the <strong>WebAssembly System Interface (WASI)</strong>, an evolving set of APIs. It's crucial to understand that WASI is not a single, monolithic standard but is currently in a significant transition, from the stable but limited <strong>WASI Preview 1</strong> (which lacks standardized networking) to the fundamentally redesigned <strong>WASI Preview 2</strong>. This newer version is built upon the still-in-proposal Component Model and introduces modular APIs for features like HTTP and sockets. Â Looking ahead, the next iteration, <a href=\"https://wasi.dev/roadmap#upcoming-wasi-03-releases\">WASI Preview 3</a>, is anticipated for release in <strong>August 2025</strong>, promising further advancements such as native async and streaming support.</p>\n<p>This layer of abstraction is the key to preserving Wasm's \"write once, run anywhere\" superpower. The WASI standard allows developers to write code in their preferred programming language (including <a href=\"https://dzone.com/articles/rust-and-webassembly-for-web-apps\">Rust</a>, C/C++, C#, Go, JavaScript, TypeScript, and Python), compile it into a single Wasm binary, and run it on any operating system or CPU architecture using a compliant runtime.. In the browser, the JavaScript engine acts as the host runtime; outside the browser, this role is filled by standalone runtimes such as Wasmtime, Wasmer, or WasmEdge, which implement the WASI standard to provide secure access to system resources.</p>\n<p>More than just enabling server-side execution, WASI introduced a fundamentally different and more secure way for programs to interact with the system. Traditional applications, following a model established by POSIX, typically inherit the permissions of the user who runs them. If a user can access a file, any program they run can also access that file, which creates a broad and implicit grant of authority.</p>\n<p>WASI, in contrast, implements a <strong>capability-based security model</strong>. By default, a Wasm module running via WASI can do nothing. It has no access to the filesystem, no ability to make network connections, and no visibility into system clocks or environment variables. To perform any of these actions, the host runtime must explicitly grant the module a 'capability'. For example, to allow a module to read files, the host must grant it a capability for a specific directory. The module receives a handle to that directory and can operate only within its confines. Any attempt to access a path outside of it will fail at the runtime level with a 'permission denied' error, even if the user running the process has permissions for that file. This enforces the <strong>Principle of Least Privilege</strong> at a granular level, a stark contrast to the traditional POSIX model where a process inherits all the ambient permissions of the user.</p>\n<p>This \" <em>deny-by-default</em> \" posture represents a paradigm shift in application security. The decision to build WASI around a capability-based model was not merely a technical convenience; it was a deliberate architectural choice that transformed Wasm from a simple performance tool into a foundational building block for trustworthy computing. The browser sandbox provided an implicit security boundary designed to protect users from malicious websites. Simply mirroring traditional OS permissions on the server would have compromised this security-first ethos. Instead, by externalizing permission management from the application to the host runtime, WASI makes security an explicit, auditable contract.</p>\n<p>This has profound implications, making Wasm uniquely suited for scenarios where the code being executed cannot be fully trusted. This includes multi-tenant serverless platforms running customer-submitted functions, extensible applications with third-party plugin systems, and edge devices executing logic from various sources. WASI did not just allow Wasm to run on the server; it defined how it would run: securely, with granular permissions, and by default, with no authority at all.</p>\n<h3>A Different Kind of Isolation: Wasm vs. Containers</h3>\n<p>For many developers today, the container has become the default unit of application deployment, a standardized box for packaging and running software. The rise of WebAssembly has introduced a new model, prompting a comparison that is less about which technology is superior and more about understanding two fundamentally different philosophies for achieving portability and isolation.</p>\n<p>The container philosophy centers on porting the entire <strong>environment</strong>. A container image, such as one built with <a href=\"https://dzone.com/articles/docker-use-cases-15-most-common-ways-to-use-docker\">Docker</a>, packages an application along with a complete slice of its user-space operating system: a filesystem, system libraries, configuration files, and all other dependencies. It achieves isolation from the host and other containers by leveraging OS-level virtualization features, primarily Linux namespaces and control groups (cgroups), which create the illusion of a private machine. The container's promise is that this self-contained environment will run consistently everywhere a container engine is installed.</p>\n<p>The WebAssembly philosophy, in contrast, is about porting only the <strong>application logic</strong>. A Wasm module is a single, self-contained binary file containing just the compiled application code. It brings no operating system, no filesystem, and no system bundled libraries. Instead, it relies on the host runtime to provide a standardized environment and to mediate access to system resources through the WASI interface. Wasm's promise is that the application logic, compiled once, will run consistently everywhere a compliant Wasm runtime is present.</p>\n<p>This philosophical divergence leads to significant practical trade-offs in size, speed, and security. Because a container must package a slice of an operating system, its image size is measured in (hundreds of) megabytes, even for simple applications. A Wasm module, containing only the application code, is orders of magnitude smaller, typically measured in kilobytes or a few megabytes. This dramatic difference impacts everything from storage costs and network transfer times to the density of workloads that can run on a single machine.</p>\n<p>The most critical distinction, particularly for modern cloud architectures, is startup speed. A container must initialize its packaged environment: a process that involves setting up namespaces, mounting the filesystem, and booting the application. This \"cold start\" can take hundreds of milliseconds, or even several seconds. A Wasm module, on the other hand, is instantiated by an already-running runtime, a process that can take less than a millisecond (for compiled languages like Rust, C or Go). This near-instantaneous startup effectively eliminates the cold start problem, making Wasm an ideal technology for event-driven, scale-to-zero architectures like serverless functions, where responsiveness is paramount.</p>\n<p>The security models also differ profoundly. Containers provide isolation at the OS kernel level. This means all containers on a host share the same kernel, which represents a large and complex attack surface. Security vulnerabilities often center on kernel exploits or misconfigurations that allow a process to \"escape\" its container and gain access to the host system. WebAssembly introduces an additional, finer-grained layer of isolation: the application-level sandbox. The attack surface is not the entire OS kernel, but the much smaller and more rigorously defined boundary of the Wasm runtime and the WASI interface. Combined with its capability-based security model, this makes Wasm \"secure by default\" and a far safer choice for running untrusted or third-party code.</p>\n<p>| Feature                 | <strong>WebAssembly (WASM)</strong>                                              | <strong>Containers</strong>                                                   |\n| ----------------------- | ------------------------------------------------------------------- | ---------------------------------------------------------------- |\n| <strong>Unit of Portability</strong> | Application Logic (a <code>.wasm</code> binary)                                | Application Environment (an OCI image with an OS filesystem)     |\n| <strong>Isolation Model</strong>     | Application-level Sandbox (deny-by-default)                         | OS-level Virtualization (namespaces, cgroups)                    |\n| <strong>Security Boundary</strong>   | Wasm Runtime &#x26; WASI Interface (small, well-defined)                 | Host OS Kernel (large, complex attack surface)                   |\n| <strong>Startup Time</strong>        | Sub-millisecond (\"zero cold start\")                                 | Hundreds of milliseconds to seconds (\"cold start\" problem)       |\n| <strong>Size / Footprint</strong>    | Kilobytes to Megabytes                                              | Megabytes to Gigabytes                                           |\n| <strong>Platform Dependency</strong> | Runtime-dependent (any OS/arch with a Wasm runtime)                 | OS and Architecture-dependent (e.g. <code>linux/amd64</code>)               |\n| <strong>Ideal Use Case</strong>      | Serverless functions, microservices, edge computing, plugin systems | Lift-and-shift legacy apps, complex stateful services, databases |</p>\n<p>Ultimately, these two technologies are not adversaries but complements. It is common to run Wasm workloads inside containers as a first step toward integrating them into existing infrastructure. Each technology is optimized for different scenarios. Containers excel at lifting and shifting existing, complex applications that depend on a full POSIX-compliant environment, such as databases or legacy monolithic services. WebAssembly shines in the world of greenfield, cloud-native development, offering a lighter, faster, and more secure foundation for building the next generation of microservices and serverless functions.</p>\n<h3>New Foundations for Platform Engineering: The Cloud and the Edge</h3>\n<p>For WebAssembly to fulfill its potential as a server-side technology, it must integrate seamlessly into the dominant paradigm for cloud infrastructure management: Kubernetes. This integration is not just possible; it is already well underway, enabled by the extensible architecture of the cloud-native ecosystem. At its core, Kubernetes orchestrates workloads by communicating with a high-level container runtime, such as containerd, on each of its worker nodes. This high-level runtime is responsible for managing images and container lifecycles, but it delegates the actual task of running a process to a low-level runtime. For traditional Linux containers, this runtime is typically <em>runc</em>.</p>\n<p>The key to running Wasm on Kubernetes lies in replacing this final link in the chain. Projects like <a href=\"https://github.com/containerd/runwasi\">runwasi</a> provide a \"shim\", a small piece of software that acts as a bridge, allowing containerd to communicate with a WebAssembly runtime (like Wasmtime or WasmEdge) just as it would with <em>runc</em>. This makes the Wasm runtime appear to Kubernetes as just another way to run workloads. The final piece of the integration is a Kubernetes object called a <em>RuntimeClass</em>, which acts as a label. By applying this label to a workload definition, developers can instruct the Kubernetes scheduler to deploy that specific workload to nodes configured with the Wasm shim, enabling Wasm modules and traditional containers to run side-by-side within the same cluster. Projects like <a href=\"https://www.spinkube.dev/\">SpinKube</a> are emerging to automate this entire setup process, making it easier for organizations to adopt Wasm without rebuilding their infrastructure from scratch.</p>\n<p>This deep integration enables new and more efficient approaches to platform engineering: the discipline of building and managing the internal platforms that development teams use to ship software. In this pattern, the platform team provides standardized components that encapsulate common, cross-cutting concerns like logging, metrics, network access, and security policies. Application developers, in turn, focus solely on writing a \"user\" component that contains pure business logic. At deployment time, these two pieces are composed into a single, tiny, and secure Wasm binary. This creates a powerful separation of concerns. Developers are freed from boilerplate code and infrastructure details, while the platform team can enforce standards, patch vulnerabilities, and evolve the platform's capabilities centrally and transparently, without requiring application teams to rebuild or redeploy their code.</p>\n<p>While these patterns are transforming the cloud, it is at the network's edge where WebAssembly's advantages become not just beneficial, but essential. Edge computing involves moving computation away from centralized data centers and closer to where data is generated and consumed: on IoT devices, in factory machinery, at retail locations, or within telecommunication networks. These environments are often severely resource-constrained, with limited CPU, memory, and power, making heavyweight containers impractical or impossible to run.</p>\n<p>WebAssembly is a near-perfect fit for this world. Its incredibly small binary size and minimal resource footprint allow it to run on devices where containers cannot. Its near-instantaneous startup times are critical for the event-driven, real-time processing required in many edge scenarios. And its true platform independence, the ability for a single compiled binary to run on any CPU architecture, be it x86, ARM, or RISC-V, is a necessity in the heterogeneous hardware landscape of the edge. This has unlocked a new wave of applications, from running machine learning inference models to executing dynamic logic within Content Delivery Networks (CDNs) with ultra-low latency.</p>\n<p>The ability of WebAssembly to operate seamlessly across these diverse environments reveals its most profound impact. Historically, software development has been siloed; building for the browser, the cloud, and embedded devices required different tools, different languages, and different deployment models. Containers helped unify deployment in the cloud, but they are foreign to the browser and too cumbersome for much of the edge. WebAssembly is the first technology to provide a single, consistent application runtime that spans this entire compute continuum. The true strength of WebAssembly lies in how its ecosystem bridges the historically separate worlds of the browser, cloud, and edge. While the final.wasm module is often tailored for its specific environment, Wasm as a standard provides a common compilation target. This allows developers to deploy applications across a vast spectrum: from a rich user interface in a web browser, to large-scale processing orchestrated by Kubernetes, and even to tiny, resource-constrained IoT devices. This reality enables a future where developers write their core business logic once and can deploy it to the most appropriate location: close to the user for low latency, in the cloud for heavy computation, or in the browser for interactivity without needing to rewrite or repackage it. This capability breaks down the architectural barriers that have long defined distributed systems, paving the way for a truly fluid and unified model of computation.</p>\n<h3>The Future is Composable: The WebAssembly Component Model</h3>\n<p>Despite its portability and security, a final, fundamental challenge has historically limited WebAssembly's potential: true interoperability. While a single Wasm module is a self-contained unit, getting multiple modules to communicate with each other effectively has been remarkably difficult. The core Wasm specification only allows for the passing of simple numeric types, integers and floats, between modules. Exchanging more complex data structures like strings, lists, or objects requires developers to manually manage pointers and memory layouts, a process that is deeply tied to the conventions of the source language and compiler. This \"impedance mismatch\" means that a Wasm module compiled from Rust cannot easily call a function in a module compiled from Go, as they represent data in fundamentally incompatible ways. This has been the primary barrier to creating a vibrant, language-agnostic ecosystem of reusable Wasm libraries, forcing developers into fragile, language-specific linking models where modules must share a single linear memory space.</p>\n<p>The <a href=\"https://component-model.bytecodealliance.org/\">WebAssembly Component Model</a> is the ambitious proposal designed to solve this final challenge. <strong>It is critical, however, to understand its current status: the Component Model is an active proposal under development, not a finalized W3C standard</strong>. While tooling and runtimes are rapidly implementing it, the specification is still subject to change. It is an evolution of the core standard that elevates Wasm from a format for individual, isolated modules into a system for building complex applications from smaller, interoperable, and language-agnostic parts. The most effective analogy for the Component Model is that it turns Wasm modules into standardized \"LEGO bricks\". Each component is a self-contained, reusable piece of software with well-defined connection points, allowing them to be snapped together to build something larger.</p>\n<p>Two key concepts make this possible: <strong>WIT</strong> and â <strong>worlds</strong> â. The WebAssembly Interface Type (WIT) is an Interface Definition Language (IDL) used to describe the \"shape\" of the connectors on these metaphorical LEGO bricks. A WIT file defines the high-level functions and rich data types such as strings, lists, variants, and records that a component either <strong>exports</strong> (provides to others) or <strong>imports</strong> (requires from its environment).</p>\n<p>Crucially, the standard <strong>WASI interfaces</strong> themselves (e.g. for filesystems or sockets) are also defined using WIT. This means developers can use the exact same language to extend the default system capabilities with their own <strong>domain-specific interfaces</strong>, creating a unified and powerful way to describe any interaction.</p>\n<p>A \"world\" is a WIT definition that describes the complete set of interfaces a component interacts with, effectively declaring all of its capabilities and dependencies. Tooling built around the Component Model, such as <a href=\"https://github.com/bytecodealliance/wit-bindgen\">wit-bindgen</a>, then automatically generates the necessary \"binding code\" for each language. This code handles the complex task of translating data between a language's native representation (e.g., a Rust String or a Python list) and a standardized, language-agnostic memory layout known as the <a href=\"https://component-model.bytecodealliance.org/advanced/canonical-abi.html\">Canonical ABI</a>. The result is seamless interoperability: a component written in C++ can call a function exported by a component written in TinyGo, passing complex data back and forth as if they were native libraries in the same language, without either needing any knowledge of the other's internal implementation.</p>\n<p>This enables a fundamentally different approach to software composition compared to the container world. Container-based architectures are typically composed at design time. Developers build discrete services, package them into containers, and then define how they interact, usually over a network via APIs, using orchestration configurations like Kubernetes manifests or Docker Compose files. This is a model for composing distributed systems. The WebAssembly Component Model enables granular composition at runtime. Components communicate through fast, standardized in-memory interfaces rather than network protocols, allowing them to be linked together within the same process. This creates a model for building applications from secure, sandboxed, and interchangeable parts.</p>\n<p>A prime example is <a href=\"https://wasmcloud.com/docs/concepts/linking-components/linking-at-runtime/\">wasmCloud</a>. In this platform, components (called actors) declare dependencies on abstract interfaces, like a key-value store. At runtime, they are dynamically linked to providers that offer concrete implementations (e.g. a Redis provider).</p>\n<p>The key advantage is that these links can be changed on the fly. You can swap the Redis provider for a different one without restarting or recompiling the application, perfectly realizing the goal of building flexible systems from truly interchangeable parts.</p>\n<p>This shift from source-level libraries to compiled, sandboxed components as the fundamental unit of software reuse represents a paradigm shift. It is the technical realization of architectural concepts like Packaged Business Capabilities (PBCs), where distinct business functions are encapsulated as autonomous, deployable software components. A Wasm component provides a near-perfect implementation of a PBC: it is a compiled, portable, and secure artifact that encapsulates specific logic. The Component Model, therefore, is not just a technical upgrade for linking code. It is the foundation for a future where software is no longer just written, but composed. Developers will be able to assemble applications from a universal ecosystem of secure, pre-built components that provide best-of-breed solutions for specific tasks, fundamentally altering the nature of the software supply chain and accelerating innovation across all languages and platforms.</p>\n<h3>Conclusion: From a Faster Web to a Universal Runtime</h3>\n<p>WebAssembly's journey has been one of remarkable and accelerating evolution. Born from the practical need to overcome performance bottlenecks in the web browser, its core principles of speed, portability, and security proved to be far more powerful than its creators may have initially envisioned. What began as a way to run C++ code alongside JavaScript has grown into a technology that is fundamentally reshaping our conception of software.</p>\n<p>The introduction of the WebAssembly System Interface (WASI) was the pivotal moment, transforming Wasm from a browser-centric tool into a viable, universal runtime for server-side computing. Its capability-based security model offered a fresh, \"secure-by-default\" alternative to traditional application architectures. This new foundation allowed Wasm to emerge as a compelling counterpart to containers, offering an unparalleled combination of lightweight footprint, near-instantaneous startup, and a hardened security sandbox that is ideally suited for the demands of serverless functions and the resource-constrained world of edge computing. Today, Wasm is not just a technology for the browser, the cloud, or the edge; it is the first to provide a single, consistent runtime that spans this entire continuum, breaking down long-standing silos in software development.</p>\n<p>Now, with the advent of the Component Model, WebAssembly is poised for its next great leap. By solving the final, critical challenge of language-agnostic interoperability, it lays the groundwork for a future where applications are not monoliths to be built, but solutions to be composed from a global ecosystem of secure, reusable, and portable software components. WebAssembly is more than just a faster way to run code; it is a foundational shift toward a more modular, more secure, and truly universal paradigm for the next era of computing.</p>\n","pageTitle":"WebAssembly: from browser plugin to the next universal runtime - by Graziano Casto","pageDescription":"WebAssembly: from browser plugin to the next universal runtime - by Graziano Casto","pageLink":"https://castograziano.com/articles/wasm-next-universal-runtime","pageImage":"https://castograziano.com/casto_graziano_personal_website.png"},"schema":{"@context":"https://schema.org","@type":"BlogPosting","headline":"WebAssembly: from browser plugin to the next universal runtime","datePublished":"2025-08-04T00:00:00.000Z","dateModified":"2025-08-04T00:00:00.000Z","author":[{"@type":"Person","name":"Graziano Casto","url":"https://castograziano.com/about-me"}]}},"__N_SSG":true}